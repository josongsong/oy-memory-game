<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>기억력 챌린지</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'IBM Plex Sans KR', sans-serif;
            overflow: hidden;
            background-color: #87CEEB; /* 하늘색 배경 */
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* UI가 3D 뷰를 가리지 않도록 */
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: auto; /* 오버레이 내 버튼 등은 클릭 가능하도록 */
        }
        #message-box {
            position: absolute;
            opacity: 0; /* 기본적으로 숨김 */
        }
        .key-indicator {
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 0.8rem;
            padding: 1rem 1.5rem;
            color: white;
            font-weight: bold;
            font-size: 1.4rem;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s ease;
        }
        
        .key-indicator:hover {
            background-color: rgba(0, 0, 0, 0.7);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .key-indicator:active {
            transform: scale(0.95);
        }
        .life {
            width: 40px;
            height: 40px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24" fill="red"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            transition: transform 0.2s ease-in-out;
        }
        .life.lost {
            transform: scale(0);
        }
        .timer-bar {
            height: 10px;
            background-color: #4CAF50;
            border-radius: 5px;
            transition: width 0.1s linear;
        }
        #progress-container {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .progress-dot {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border: 3px solid rgba(34, 197, 94, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(34, 197, 94, 0.8);
            font-size: 32px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* 텍스트 애니메이션 */
        @keyframes slide-up {
            from { opacity: 0; transform: translate(-50%, -250%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, -320%) scale(1); }
        }
        .animate-up { animation: slide-up 0.3s ease-out forwards; }

        @keyframes slide-down {
            from { opacity: 0; transform: translate(-50%, 200%) scale(0.8); }
            to { opacity: 1; transform: translate(-50%, 450%) scale(1); }
        }
        .animate-down { animation: slide-down 0.3s ease-out forwards; }

        @keyframes slide-left {
            from { opacity: 0; transform: translate(-180%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(-220%, -50%) scale(1); }
        }
        .animate-left { animation: slide-left 0.3s ease-out forwards; }

        @keyframes slide-right {
            from { opacity: 0; transform: translate(80%, -50%) scale(0.8); }
            to { opacity: 1; transform: translate(120%, -50%) scale(1); }
        }
        .animate-right { animation: slide-right 0.3s ease-out forwards; }


        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        #start-button.pulsing {
             animation: pulse 2s infinite;
        }
        #flash-overlay {
            transition: opacity 0.1s ease-out;
        }
        #volume-controls {
            pointer-events: auto;
        }
        
        /* 플랫한 세로 슬라이더 */
        .slider-flat {
            -webkit-appearance: none;
            appearance: none;
            background: #333;
            outline: none;
            border: none;
            border-radius: 2px;
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* WebKit */
            transition: background-color 0.2s ease;
        }
        
        .slider-flat:hover {
            background: #444;
        }
        
        .slider-flat::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #333;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .slider-flat::-webkit-slider-thumb:hover {
            background: #f0f0f0;
            border-color: #555;
        }
        
        .slider-flat::-webkit-slider-thumb:active {
            background: #e0e0e0;
            transform: scale(0.95);
        }
        
        .slider-flat::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #333;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .slider-flat::-moz-range-thumb:hover {
            background: #f0f0f0;
            border-color: #555;
        }
        
        /* Firefox에서 세로 슬라이더 지원 */
        .slider-flat[orient="vertical"] {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
        }
        
        /* IQ 숫자 zoom 효과 */
        .iq-zoom {
            animation: iqZoom 0.6s ease-in-out;
        }
        
        @keyframes iqZoom {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-gray-800 text-white">

    <div id="game-container">
        <!-- 3D 렌더링이 이루어질 캔버스. 두근-->
        <div id="canvas-container" class="w-full h-full"></div>
        
        <div id="flash-overlay" class="absolute inset-0 bg-red-500 opacity-0 pointer-events-none"></div>

        <!-- 게임 UI -->
        <div id="ui-layer">
             <!-- 상단 UI: 스테이지, 라이프 -->
            <div class="w-full flex justify-between items-center p-4 md:p-8">
                <h1 id="stage-display" class="text-2xl md:text-4xl font-bold text-white" style="text-shadow: 2px 2px 4px #000000;"></h1>
                <div id="lives-container" class="flex space-x-2">
                    <div class="life"></div>
                    <div class="life"></div>
                    <div class="life"></div>
                </div>
            </div>
            
            <!-- 진행상황ㅇ 표시 -->
            <div id="progress-container"></div>

            <!-- 중앙: 캐릭터 멘트 -->
            <div id="message-box" class="text-6xl md:text-8xl font-bold text-yellow-300" style="text-shadow: 3px 3px 6px #000000;"></div>
            <!-- // 하단 UI: 타이머 -->
            <div class="absolute bottom-0 left-0 right-0 w-full flex flex-col items-center space-y-4 p-4 md:p-8">
                 <div id="timer-container" class="w-full max-w-md bg-gray-700 rounded-full overflow-hidden opacity-0">
                    <div id="timer-bar" class="timer-bar"></div>
                </div>
            </div>

            <!-- 좌측 하단: 볼륨 조절 -->
            <div id="volume-controls" class="absolute bottom-4 left-4 flex space-x-6 bg-black bg-opacity-70 p-6 rounded-xl backdrop-blur-sm border border-white border-opacity-30">
                <!-- 배경음악 -->
                <div class="flex flex-col items-center space-y-3">
                    <div class="flex flex-col items-center space-y-1">
                        <span class="text-white text-sm font-semibold">음악</span>
                    </div>
                    <div class="relative">
                        <input type="range" id="bgm-volume" min="0" max="100" class="w-4 h-32 appearance-none cursor-pointer slider-flat" orient="vertical">
                    </div>
                </div>
                
                <!-- 효과음 -->
                <div class="flex flex-col items-center space-y-3">
                    <div class="flex flex-col items-center space-y-1">
                        <span class="text-white text-sm font-semibold">소리</span>
                    </div>
                    <div class="relative">
                        <input type="range" id="sfx-volume" min="0" max="100" class="w-4 h-32 appearance-none cursor-pointer slider-flat" orient="vertical">
                    </div>
                </div>
            </div>

            <!-- 우측 하단: 화살표 버튼 -->
            <div class="absolute bottom-4 right-4 pointer-events-auto">
                <!-- 화살표 방향에 맞는 배열 -->
                <div class="flex flex-col items-center space-y-2">
                    <!-- 위쪽 화살표 -->
                    <button class="key-indicator hover:bg-opacity-80 transition-all duration-200 transform hover:scale-105 active:scale-95 cursor-pointer" data-key="ArrowUp">↑ 트렌드리딩</button>
                    
                    <!-- 좌우 화살표 -->
                    <div class="flex space-x-4">
                        <button class="key-indicator hover:bg-opacity-80 transition-all duration-200 transform hover:scale-105 active:scale-95 cursor-pointer" data-key="ArrowLeft">← 협업,소통</button>
                        <button class="key-indicator hover:bg-opacity-80 transition-all duration-200 transform hover:scale-105 active:scale-95 cursor-pointer" data-key="ArrowRight">→ 함께성장</button>
                    </div>
                    
                    <!-- 아래쪽 화살표 -->
                    <button class="key-indicator hover:bg-opacity-80 transition-all duration-200 transform hover:scale-105 active:scale-95 cursor-pointer" data-key="ArrowDown">↓ 강한실행력</button>
                </div>
            </div>
        </div>

        <!-- 시작 화면 -->
        <div id="start-screen" class="overlay absolute inset-0 bg-black bg-opacity-70 flex flex-col justify-center items-center text-center p-4">
            <h1 class="text-5xl md:text-7xl font-bold mb-4">올영력 챌린지!</h1>
            <p class="text-lg md:text-xl mb-8 max-w-2xl">
            
            올리브영의 일하는 방식 구호에 맞춰 케릭터가 움직이고 키보드 화살표가 눌립니다. <br>그 동작을 차례대로 기억해 두었다가, 구호가 끝나면 키보드를 눌러 따라해주세요!</p>
            <button id="start-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-3 px-8 rounded-lg text-2xl transition-transform transform hover:scale-105">시작하기</button>
        </div>

        <!-- 게임 오버 화면 -->

        <div id="game-over-screen" class="overlay absolute inset-0 bg-black bg-opacity-70 flex flex-col justify-center items-center text-center p-4 hidden">
            <h1 class="text-6xl md:text-8xl font-bold mb-4">게임 오버!!</h1>
            <button id="retry-button" class="bg-green-500 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-2xl transition-transform transform hover:scale-105">다시 도전</button>
        </div>
    </div>
    
    
    <audio id="bgm" loop src="Pixel Dreams.mp3"></audio>

    <script>
    
        const INITIAL_LIVES = 3;
        const INITIAL_STAGE = 1;
        const INITIAL_SEQUENCE_SPEED = 800; // ms, 숫자가 작을수록 빨라짐
        const INITIAL_TIME_LIMIT = 5000;    // ms, 플레이어 입력 시간
        const SHAKE_INTENSITY = 0.1;        // 게임 오버 시 화면 흔들림 강도
        
        // --- 사운드 설정 ---
        const BGM_DEFAULT_VOLUME = 50; // 배경음악 초기 볼륨 (0-100)
        const SFX_DEFAULT_VOLUME = 80; // 효과음 초기 볼륨 (0-100)
        
        // --- 설정 끝 ---


        // --- THREE.js 셋업 ---
        let scene, camera, renderer, character, clock;
        let waterParticles = [];
        let birds = [];
        let hotAirBalloons = [];
        const canvasContainer = document.getElementById('canvas-container');
        let mouse = new THREE.Vector2();

        const keywords = {
            'ArrowUp': '↑ 트렌드리딩',
            'ArrowDown': '↓ 강한실행력',
            'ArrowLeft': '← 협업,소통',
            'ArrowRight': '→ 함께성장'
        };
        const arrowIcons = {
            'ArrowUp': '↑',
            'ArrowDown': '↓',
            'ArrowLeft': '←',
            'ArrowRight': '→'
        };

        // --- 게임 상태 변수 ---
        let gameState = 'START'; // START, SHOWING, WAITING, GAMEOVER
        let sequence = [];
        let playerInput = [];
        let stage;
        let lives;
        let sequenceSpeed;
        let timeLimit;
        let timerInterval;
        let shakeDuration = 0;

        // --- UI 요소 ---
        const stageDisplay = document.getElementById('stage-display');
        const livesContainer = document.getElementById('lives-container');
        const messageBox = document.getElementById('message-box');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const retryButton = document.getElementById('retry-button');
        const timerContainer = document.getElementById('timer-container');
        const timerBar = document.getElementById('timer-bar');
        const progressContainer = document.getElementById('progress-container');
        const flashOverlay = document.getElementById('flash-overlay');
        const bgm = document.getElementById('bgm');
        const bgmVolumeSlider = document.getElementById('bgm-volume');
        const sfxVolumeSlider = document.getElementById('sfx-volume');
        
        // Web Audio API context
        let audioCtx;
        let sfxVolume = SFX_DEFAULT_VOLUME / 100;

        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 4, 5);
            camera.lookAt(0, 0.5, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            canvasContainer.appendChild(renderer.domElement);
            
            clock = new THREE.Clock();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.4; // 땅을 아래로 내림
            ground.receiveShadow = true;
            scene.add(ground);

            createFoliage();
            createClouds();
            createBirds();
            createHotAirBalloons();
            createCharacter();
            
            // 게임 초기화 시점부터 걸어다니기 시작
            setTimeout(() => {
                if (gameState === 'START') {
                    startWalking();
                }
            }, 1000);
            
            animate();
        }
        
        function createHotAirBalloons() {
            for (let i = 0; i < 8; i++) {
                const balloonGroup = new THREE.Group();
                const balloonGeo = new THREE.SphereGeometry(1.5, 16, 16);
                const balloonMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(Math.random(), Math.random(), Math.random()) });
                const balloon = new THREE.Mesh(balloonGeo, balloonMat);

                const basketGeo = new THREE.BoxGeometry(0.8, 0.6, 0.8);
                const basketMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const basket = new THREE.Mesh(basketGeo, basketMat);
                basket.position.y = -1.8;

                balloonGroup.add(balloon);
                balloonGroup.add(basket);

                balloonGroup.position.set(
                    (Math.random() - 0.5) * 60,
                    Math.random() * 8 + 5,
                    (Math.random() - 0.5) * 40 - 25
                );
                scene.add(balloonGroup);
                hotAirBalloons.push(balloonGroup);
            }
        }


        function createFoliage() {
            const flowerColors = [0xff69b4, 0xffff00, 0xffffff];
            const foliageGroup = new THREE.Group();
            const grassGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 5);
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x008000 });
            for(let i = 0; i < 300; i++) {
                const grass = new THREE.Mesh(grassGeo, grassMat);
                const x = (Math.random() - 0.5) * 50;
                const z = (Math.random() - 0.5) * 50;
                grass.position.set(x, -0.25, z); // 잔디를 땅과 함께 아래로 내림
                grass.rotation.x = (Math.random() - 0.5) * 0.2;
                grass.rotation.z = (Math.random() - 0.5) * 0.2;
                foliageGroup.add(grass);
            }
            const stemGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 5);
            const stemMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const petalGeo = new THREE.SphereGeometry(0.1, 8, 8);
            for(let i = 0; i < 50; i++) {
                const flower = new THREE.Group();
                const stem = new THREE.Mesh(stemGeo, stemMat);
                const petalMat = new THREE.MeshStandardMaterial({ color: flowerColors[Math.floor(Math.random()*flowerColors.length)] });
                const petal = new THREE.Mesh(petalGeo, petalMat);
                petal.position.y = 0.25;
                flower.add(stem);
                flower.add(petal);
                const x = (Math.random() - 0.5) * 50;
                const z = (Math.random() - 0.5) * 50;
                flower.position.set(x, -0.15, z); // 꽃
                foliageGroup.add(flower);
            }
            scene.add(foliageGroup);
        }

        function createClouds() {
            const cloudGeo = new THREE.SphereGeometry(1, 8, 8);
            const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            for (let i = 0; i < 10; i++) {
                const cloud = new THREE.Group();
                for (let j = 0; j < 5; j++) {
                    const part = new THREE.Mesh(cloudGeo, cloudMat);
                    part.position.set((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 1, (Math.random() - 0.5) * 1);
                    part.scale.setScalar(Math.random() * 0.5 + 0.5);
                    cloud.add(part);
                }
                cloud.position.set((Math.random() - 0.5) * 80, Math.random() * 5 + 10, (Math.random() - 0.5) * 80 - 30);
                scene.add(cloud);
            }
        }

        function createBirds() {
            const birdGeo = new THREE.BoxGeometry(0.3, 0.05, 0.1);
            const birdMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
            for (let i = 0; i < 5; i++) {
                const bird = new THREE.Group();
                const wing1 = new THREE.Mesh(birdGeo, birdMat);
                wing1.position.x = -0.15;
                const wing2 = new THREE.Mesh(birdGeo, birdMat);
                wing2.position.x = 0.15;
                bird.add(wing1);
                bird.add(wing2);
                bird.position.set((Math.random() - 0.5) * 100, Math.random() * 5 + 12, (Math.random() - 0.5) * 40 - 40);
                bird.velocity = new THREE.Vector3(Math.random() * 2 + 2, 0, 0);
                scene.add(bird);
                birds.push(bird);
            }
        }

        function createTextMaterial(text, width = 256, height = 512, side = 'front') {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height; // 몸통 비율에 맞게 조정
            const context = canvas.getContext('2d');
            
            // 올리브영 녹색 배경
            context.fillStyle = '#7CB342';
            context.fillRect(0, 0, width, height);
            
            // 글자 스타일
            context.font = `Bold ${width * 0.8}px 'IBM Plex Sans KR'`;
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, width / 2, height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            return new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8, metalness: 0.1 });
        }


        function createCharacter() {
            character = new THREE.Group();
            scene.add(character);
            character.position.y = 0.5;
            character.rotation.y = 0; // 캐릭터가 항상 카메라를 보도록 고정
            
            const characterMaterial = new THREE.MeshStandardMaterial({ roughness: 0.8, metalness: 0.1 });
            const isFemale = Math.random() > 0.5;
            const skinColor = 0xFFDAB9;
            const pantsColor = 0x464646;
            
            // Minecraft 스타일 머리 - 각 면마다 다른 색상
            const headGeo = new THREE.BoxGeometry(0.8, 0.8, 0.6);
            const hairColor = 0x3b2219; // 머리카락색
            
            // 머리 재질 배열 - 앞면은 살색, 나머지는 머리카락색
            const headMaterials = [
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 }), // right - 머리카락색
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 }), // left - 머리카락색
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 }), // top - 머리카락색
                new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 }), // bottom - 머리카락색
                new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 }), // back - 머리카락색
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 })  // front - 살색 (얼굴)
            ];
            
            const head = new THREE.Mesh(headGeo, headMaterials);
            head.castShadow = true;
            head.position.y = 0.6;
            character.add(head);
            character.head = head;

            // 얼굴 요소들 - 살색 앞면에 그리기


            const faceComponentsZ = 0.31 

            // 이마 헤어
            const foreheadHairGeo = new THREE.BoxGeometry(0.8, 0.3, 0.01);
            const foreheadHairMaterial = new THREE.MeshBasicMaterial({ color: hairColor });
            const foreheadHair = new THREE.Mesh(foreheadHairGeo, foreheadHairMaterial);
            foreheadHair.position.set(0, 0.3, faceComponentsZ); // 이마 부분에 배치
            head.add(foreheadHair);
            character.foreheadHair = foreheadHair;
            

            // 눈
            const eyeGeo = new THREE.BoxGeometry(0.1, 0.2, 0.00);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: '#241478' }); // Dark Blue
            const leftEye = new THREE.Mesh(eyeGeo, eyeMaterial.clone());
            leftEye.position.set(0.15, -0.02, faceComponentsZ); // 살색 앞면에 배치
            head.add(leftEye);
            character.leftEye = leftEye;

            const rightEye = new THREE.Mesh(eyeGeo, eyeMaterial.clone());
            rightEye.position.set(-0.15, -0.02, faceComponentsZ); // 살색 앞면에 배치
            head.add(rightEye);
            character.rightEye = rightEye;
            
            // 코
            const noseGeo = new THREE.BoxGeometry(0.05, 0.05, 0);
            const noseMaterial = new THREE.MeshBasicMaterial({ color: '#66442c' });
            const nose = new THREE.Mesh(noseGeo, noseMaterial);
            nose.position.set(0, -0.1, faceComponentsZ); // 살색 앞면에 배치
            head.add(nose);
            character.nose = nose;

            // 입
            const mouthGeo = new THREE.BoxGeometry(0.2, 0.1, 0);
            const mouthMaterial = new THREE.MeshBasicMaterial({ color: '#66442c' });
            const mouth = new THREE.Mesh(mouthGeo, mouthMaterial);
            mouth.position.set(0, -0.25, faceComponentsZ); // 살색 앞면에 배치
            head.add(mouth);
            character.mouth = mouth;

            // Minecraft 스타일 몸통
            const bodyGeo = new THREE.BoxGeometry(0.8, 0, 0.4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 }); // 살색 몸통
            const body = new THREE.Mesh(bodyGeo, bodyMaterial);
            body.castShadow = true;
            character.add(body);
            character.body = body;

            // 반팔 티셔츠 - 올리브영 그린 컬러
            const shirtGeo = new THREE.BoxGeometry(0.85, 0.7, 0.45);
            
            // 티셔츠 재질 배열 - 앞면에 '올', 뒷면에 '영'
            const frontShirtMaterial = createTextMaterial('영', 100, 100);
            const backShirtMaterial = createTextMaterial('올', 100, 100);
            const sideShirtMaterial = new THREE.MeshStandardMaterial({ color: 0x7CB342, roughness: 0.8, metalness: 0.1 }); // 올리브영 그린
            
            const shirtMaterials = [
                sideShirtMaterial, // right - 올리브영 그린
                sideShirtMaterial, // left - 올리브영 그린
                sideShirtMaterial, // top - 올리브영 그린
                sideShirtMaterial, // bottom - 올리브영 그린
                backShirtMaterial,  // back - '영' 텍스트
                frontShirtMaterial  // front - '올' 텍스트
            ];
            
            const shirt = new THREE.Mesh(shirtGeo, shirtMaterials);
            shirt.castShadow = true;
            shirt.position.y = -0.15; // 몸통 아래쪽에 위치 (얼굴 아래)
            character.add(shirt);
            character.shirt = shirt;

            // 반팔 팔 - 살색
            const armGeo = new THREE.BoxGeometry(0.3, 0.5, 0.3);
            const armMaterial = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 });
            
            const leftArm = new THREE.Mesh(armGeo, armMaterial);
            leftArm.castShadow = true;
            leftArm.position.set(0.55, -0.1, 0);
            character.add(leftArm);
            character.leftArm = leftArm;
            
            const rightArm = new THREE.Mesh(armGeo, armMaterial);
            rightArm.castShadow = true;
            rightArm.position.set(-0.55, -0.1, 0);
            character.add(rightArm);
            character.rightArm = rightArm;

            // 다리 - 바지 색상
            const legGeo = new THREE.BoxGeometry(0.35, 0.8, 0.35);
            const legMaterial = new THREE.MeshStandardMaterial({ color: pantsColor, roughness: 0.8, metalness: 0.1 });
            
            const leftLeg = new THREE.Mesh(legGeo, legMaterial);
            leftLeg.castShadow = true;
            leftLeg.position.set(0.2, -0.9, 0);
            character.add(leftLeg);
            character.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeo, legMaterial);
            rightLeg.castShadow = true;
            rightLeg.position.set(-0.2, -0.9, 0);
            character.add(rightLeg);
            character.rightLeg = rightLeg;
        }
        
        function playSound(type) {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser");
                    return;
                }
            }
            
            let oscillator = audioCtx.createOscillator();
            let gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            gainNode.gain.setValueAtTime(0.2 * sfxVolume, audioCtx.currentTime);

            switch(type) {
                case 'ArrowUp': // 동일한 효과음
                case 'ArrowDown': // 동일한 효과음
                case 'ArrowLeft': // 동일한 효과음
                case 'ArrowRight': // 동일한 효과음
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(660, audioCtx.currentTime + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.15);
                    break;
                case 'beep': // 카운트다운 뚯뚯 소리
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
                    break;
                case 'success': // 경쾌한 시작 소리
                    oscillator.type = 'sine';
                    // 상승하는 멜로디 (도-미-솔-도)
                    const successFreqs = [523, 659, 784, 1047]; // C5, E5, G5, C6
                    successFreqs.forEach((freq, i) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.1);
                        gain.gain.setValueAtTime(0.15 * sfxVolume, audioCtx.currentTime + i * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + i * 0.1 + 0.3);
                        osc.start(audioCtx.currentTime + i * 0.1);
                        osc.stop(audioCtx.currentTime + i * 0.1 + 0.3);
                    });
                    return;
                case 'incorrect': // Incorrect sound
                     oscillator.type = 'sawtooth';
                     oscillator.frequency.setValueAtTime(164, audioCtx.currentTime);
                     oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                     gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.3);
                     break;
                case 'gameover': // More Dramatic Game Over sound
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.3 * sfxVolume, audioCtx.currentTime);

                    // A rapid, descending minor scale
                    let freqsOver = [440, 415, 392, 349, 330, 294, 277, 261]; 
                    freqsOver.forEach((freq, i) => {
                         oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.07);
                    });
                    
                    // Final low, sustained note
                    oscillator.frequency.setValueAtTime(130, audioCtx.currentTime + freqsOver.length * 0.07);

                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 1.2);
                    break;
            }

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 1.2);
        }

        function playAnimation(key) {
            playSound(key);
            // 모든 애니메이션 상태 초기화
            const resetAnimation = () => {
                character.leftArm.rotation.set(0, 0, 0);
                character.rightArm.rotation.set(0, 0, 0);
                character.leftLeg.rotation.set(0, 0, 0);
                character.rightLeg.rotation.set(0, 0, 0);
                character.head.rotation.set(0, 0, 0);
                character.rightArm.position.z = 0;
                character.position.y = 0.5;
                // character.rotation.y = Math.PI;
            };
            resetAnimation();

            const duration = 400; // ms

            switch(key) {
                case 'ArrowUp': // 트렌드리딩 - 멀리보기
                    character.head.rotation.x = -Math.PI / 16;
                    character.rightArm.rotation.x = -Math.PI / 2.5;
                    character.rightArm.position.z = -0.1; // 손을 앞으로 조금
                    setTimeout(resetAnimation, duration);
                    break;

                case 'ArrowDown': // 강한실행력 - 파워 스톰프
                    character.position.y = 0.3; // 살짝 웅크리기
                    character.leftLeg.rotation.x = -Math.PI / 4;
                    character.rightLeg.rotation.x = Math.PI / 4;
                    setTimeout(() => {
                        character.position.y = 0.7; // 점프!
                    }, 100);
                     setTimeout(() => {
                        character.position.y = 0.5; // 착지
                        character.leftLeg.rotation.x = 0;
                        character.rightLeg.rotation.x = 0;
                    }, 250);
                    setTimeout(resetAnimation, duration);
                    break;

                case 'ArrowLeft': // 협업,소통 - 신나는 댄스
                    character.rotation.y = Math.PI / 8;
                    character.leftArm.rotation.z = Math.PI / 4;
                    character.rightArm.rotation.z = -Math.PI / 4;
                    setTimeout(() => {
                        character.rotation.y = Math.PI / 8;
                        character.leftArm.rotation.z = -Math.PI / 4;
                        character.rightArm.rotation.z = Math.PI / 4;
                    }, duration / 2);
                    setTimeout(resetAnimation, duration);
                    break;

                case 'ArrowRight': // 함께성장 - 환호!
                    character.leftArm.rotation.x = -Math.PI * 0.9;
                    character.rightArm.rotation.x = -Math.PI * 0.9;
                    character.rightLeg.rotation.x = -Math.PI / 4; // 한쪽 다리 들기
                    setTimeout(resetAnimation, duration);
                    break;
            }
        }
        
        function createWaterSplash() {
            const particleCount = 100;
            const particleGeo = new THREE.SphereGeometry(0.05, 8, 8);
            const particleMat = new THREE.MeshBasicMaterial({ color: 0x00BFFF });

            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(character.position);
                particle.position.y += 0.8;
                
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    (Math.random() * 2 + 2),
                    (Math.random() - 0.5) * 3
                );
                scene.add(particle);
                waterParticles.push(particle);
            }
        }
        
        // 대기화면 캐릭터 애니메이션
        let idleAnimationTimer = 0;
        let lastIdleAction = 0;
        const idleActions = ['dance', 'stretch', 'wave', 'nod', 'grassWalk'];
        
        // 걸어다니기 애니메이션
        let walkAnimationTimer = 0;
        let walkTargetPosition = { x: 0, z: 0 };
        let walkStartPosition = { x: 0, z: 0 };
        let walkProgress = 0;
        let isWalking = false;
        let walkDuration = 0;

        function startWalking() {
            if (!character || isWalking) return;
            
            // 랜덤한 목표 위치 설정 (원점에서 1-2.5 유닛 거리로 제한)
            const angle = Math.random() * Math.PI * 2;
            const distance = 1 + Math.random() * 1.5; // 1-2.5 유닛으로 제한
            walkTargetPosition.x = Math.cos(angle) * distance;
            walkTargetPosition.z = Math.sin(angle) * distance;
            
            // 카메라에서 너무 멀어지지 않도록 추가 제한
            const maxDistance = 2.5;
            const currentDistance = Math.sqrt(walkTargetPosition.x * walkTargetPosition.x + walkTargetPosition.z * walkTargetPosition.z);
            if (currentDistance > maxDistance) {
                const scale = maxDistance / currentDistance;
                walkTargetPosition.x *= scale;
                walkTargetPosition.z *= scale;
            }
            
            // 현재 위치를 시작 위치로 설정
            walkStartPosition.x = character.position.x;
            walkStartPosition.z = character.position.z;
            
            // 걸어다니기 설정
            isWalking = true;
            walkProgress = 0;
            walkDuration = 3000 + Math.random() * 2000; // 3-5초
            
            // 캐릭터가 목표를 바라보도록 회전
            const dx = walkTargetPosition.x - walkStartPosition.x;
            const dz = walkTargetPosition.z - walkStartPosition.z;
            const targetRotation = Math.atan2(dx, dz);
            character.rotation.y = targetRotation;
        }
        
        function updateWalking(delta) {
            if (!isWalking || !character) return;
            
            walkProgress += delta * 1000; // 밀리초로 변환
            const t = Math.min(walkProgress / walkDuration, 1);
            
            // 부드러운 보간 (ease-in-out)
            const smoothT = t * t * (3 - 2 * t);
            
            // 위치 업데이트
            let newX = walkStartPosition.x + (walkTargetPosition.x - walkStartPosition.x) * smoothT;
            let newZ = walkStartPosition.z + (walkTargetPosition.z - walkStartPosition.z) * smoothT;
            
            // 실시간 거리 체크 및 제한 (2.5 유닛 이내로 제한)
            const currentDistance = Math.sqrt(newX * newX + newZ * newZ);
            const maxDistance = 2.5;
            if (currentDistance > maxDistance) {
                const scale = maxDistance / currentDistance;
                newX *= scale;
                newZ *= scale;
            }
            
            character.position.x = newX;
            character.position.z = newZ;
            
            // 걸음걸이 애니메이션 (다리 움직임)
            const walkCycle = Math.sin(walkProgress * 0.01) * 0.3;
            character.leftLeg.rotation.x = walkCycle;
            character.rightLeg.rotation.x = -walkCycle;
            
            // 팔 흔들기
            character.leftArm.rotation.x = -walkCycle * 0.5;
            character.rightArm.rotation.x = walkCycle * 0.5;
            
            // 목표에 도달했으면
            if (t >= 1) {
                isWalking = false;
                character.leftLeg.rotation.x = 0;
                character.rightLeg.rotation.x = 0;
                character.leftArm.rotation.x = 0;
                character.rightArm.rotation.x = 0;
                
                // 잠시 대기 후 다시 걸어다니기 시작
                setTimeout(() => {
                    if (gameState === 'START') {
                        startWalking();
                    }
                }, 2000 + Math.random() * 3000);
            }
        }
        
        function teleportToCenter() {
            if (!character) return;
            
            // 순간이동 효과 (펑!)
            const originalScale = character.scale.clone();
            character.scale.set(0.1, 0.1, 0.1);
            character.position.set(0, 0.5, 0);
            character.rotation.y = Math.PI;
            
            // 부드럽게 원래 크기로 복원
            const scaleUp = () => {
                if (character) {
                    character.scale.lerp(originalScale, 0.1);
                    if (character.scale.distanceTo(originalScale) > 0.01) {
                        requestAnimationFrame(scaleUp);
                    } else {
                        character.scale.copy(originalScale);
                    }
                }
            };
            scaleUp();
        }

        function playIdleAnimation() {
            if (!character) return;
            
            const action = idleActions[Math.floor(Math.random() * idleActions.length)];
            const duration = 2000; // 2초
            
            switch(action) {
                case 'dance':
                    // 춤추기 - 좌우로 흔들리며 팔을 움직임
                    character.rotation.y = Math.PI / 8;
                    character.leftArm.rotation.z = Math.PI / 4;
                    character.rightArm.rotation.z = -Math.PI / 4;
                    setTimeout(() => {
                        if (character) {
                            character.rotation.y = 0;
                            character.leftArm.rotation.z = 0;
                            character.rightArm.rotation.z = 0;
                        }
                    }, duration);
                    break;
                    
                case 'grassWalk':
                    // 잔디밭을 걸어다니기 - 작은 걸음으로 잔디밭을 탐험
                    const grassWalkDuration = 4000; // 4초
                    const grassWalkSteps = 8;
                    let stepIndex = 0;
                    
                    const grassWalkInterval = setInterval(() => {
                        if (character && stepIndex < grassWalkSteps) {
                            // 작은 걸음걸이
                            const stepCycle = Math.sin(stepIndex * 0.5) * 0.2;
                            character.leftLeg.rotation.x = stepCycle;
                            character.rightLeg.rotation.x = -stepCycle;
                            
                            // 팔 흔들기
                            character.leftArm.rotation.x = -stepCycle * 0.3;
                            character.rightArm.rotation.x = stepCycle * 0.3;
                            
                            // 몸을 좌우로 살짝 기울이기
                            character.rotation.z = Math.sin(stepIndex * 0.3) * 0.1;
                            
                            // 머리를 좌우로 살짝 돌리기 (잔디를 보는 듯한 동작)
                            character.head.rotation.y = Math.sin(stepIndex * 0.4) * 0.2;
                            
                            stepIndex++;
                        } else {
                            clearInterval(grassWalkInterval);
                            if (character) {
                                character.leftLeg.rotation.x = 0;
                                character.rightLeg.rotation.x = 0;
                                character.leftArm.rotation.x = 0;
                                character.rightArm.rotation.x = 0;
                                character.rotation.z = 0;
                                character.head.rotation.y = 0;
                            }
                        }
                    }, 500);
                    break;
                    
                case 'stretch':
                    // 스트레치 - 양팔을 위로 올리고 몸을 뒤로 젖힘
                    character.leftArm.rotation.x = -Math.PI / 2;
                    character.rightArm.rotation.x = -Math.PI / 2;
                    character.head.rotation.x = -Math.PI / 12;
                    setTimeout(() => {
                        if (character) {
                            character.leftArm.rotation.x = 0;
                            character.rightArm.rotation.x = 0;
                            character.head.rotation.x = 0;
                        }
                    }, duration);
                    break;
                    
                case 'wave':
                    // 손 흔들기 - 한쪽 팔만 흔들기
                    character.rightArm.rotation.x = -Math.PI / 4;
                    character.rightArm.rotation.z = Math.PI / 6;
                    setTimeout(() => {
                        if (character) {
                            character.rightArm.rotation.x = 0;
                            character.rightArm.rotation.z = 0;
                        }
                    }, duration);
                    break;
                    
                case 'nod':
                    // 고개 끄덕이기 - 머리를 위아래로 움직임
                    const nodCount = 3;
                    let nodIndex = 0;
                    const nodInterval = setInterval(() => {
                        if (character && nodIndex < nodCount) {
                            character.head.rotation.x = nodIndex % 2 === 0 ? -Math.PI / 16 : Math.PI / 16;
                            nodIndex++;
                        } else {
                            clearInterval(nodInterval);
                            if (character) character.head.rotation.x = 0;
                        }
                    }, 300);
                    break;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            if (waterParticles.length > 0) {
                waterParticles.forEach((p, index) => {
                    p.velocity.y -= 9.8 * delta;
                    p.position.addScaledVector(p.velocity, delta);
                    if (p.position.y < 0) {
                        scene.remove(p);
                        waterParticles.splice(index, 1);
                    }
                });
            }

            birds.forEach(bird => {
                bird.position.addScaledVector(bird.velocity, delta);
                // 날갯짓
                bird.children[0].rotation.z = Math.sin(elapsedTime * 20) * 0.5;
                bird.children[1].rotation.z = -Math.sin(elapsedTime * 20) * 0.5;
                if (bird.position.x > 60) {
                    bird.position.x = -60;
                    bird.position.y = Math.random() * 5 + 12;
                }
            });
            
            hotAirBalloons.forEach(balloon => {
                 balloon.position.y += Math.sin(elapsedTime * 0.5 + balloon.position.x) * 0.005;
            });

            // 대기화면에서만 애니메이션 실행 (카운트다운 중에는 중단)
            const startScreen = document.getElementById('start-screen');
            const countdownElement = document.getElementById('countdown');
            const isStartScreenVisible = startScreen && !startScreen.classList.contains('hidden');
            const isCountdownVisible = countdownElement && countdownElement.style.display !== 'none';
            
            // 오직 대기화면에서만 애니메이션 실행 (카운트다운 중에는 완전히 중단)
            if (isStartScreenVisible && !isCountdownVisible && character) {
                idleAnimationTimer += delta * 1000; // 밀리초로 변환
                
                // 걸어다니기 업데이트
                updateWalking(delta);
                
                // 3-8초마다 랜덤 애니메이션 실행 (걸어다니지 않을 때만)
                if (!isWalking && idleAnimationTimer - lastIdleAction > 3000 + Math.random() * 5000) {
                    playIdleAnimation();
                    lastIdleAction = idleAnimationTimer;
                }
            } else {
                // 대기화면이 아니거나 카운트다운 중일 때는 모든 애니메이션 중단
                if (isWalking) {
                    isWalking = false;
                    if (character) {
                        character.leftLeg.rotation.x = 0;
                        character.rightLeg.rotation.x = 0;
                        character.leftArm.rotation.x = 0;
                        character.rightArm.rotation.x = 0;
                        character.rotation.z = 0;
                        character.head.rotation.y = 0;
                    }
                }
            }

            // Mouse-based camera movement
            const targetX = mouse.x * 0.8; 
            const targetY = 1.5 + mouse.y * 0.4;
            
            // Smoothly interpolate camera position
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (targetY - camera.position.y) * 0.05;
            
            if (shakeDuration > 0) {
                camera.position.x += (Math.random() - 0.5) * SHAKE_INTENSITY;
                camera.position.y += (Math.random() - 0.5) * SHAKE_INTENSITY;
                shakeDuration -= delta;
            }

            camera.lookAt(0, 1, 0);

            renderer.render(scene, camera);
        }

        function startGame() {
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            
            // 3초 카운트다운 시작
            startCountdown();
        }

        function startCountdown() {
            // 카운트다운 시작 시 캐릭터를 제자리로 돌아오게 하기
            if (character) {
                isWalking = false;
                character.position.set(0, 0.5, 0);
                character.rotation.y = 0;
                character.leftLeg.rotation.x = 0;
                character.rightLeg.rotation.x = 0;
                character.leftArm.rotation.x = 0;
                character.rightArm.rotation.x = 0;
                character.rotation.z = 0;
                character.head.rotation.y = 0;
            }
            
            // 카운트다운 상태에서 소리 UI 보이기
            showVolumeControls();
            
            let count = 3;
            const countdownElement = document.createElement('div');
            countdownElement.id = 'countdown';
            countdownElement.style.cssText = `
                position: fixed;
                top: 200px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 120px;
                font-weight: bold;
                color: #FFD700;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                z-index: 1000;
                pointer-events: none;
                width: 300px;
                height: 120px;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
                line-height: 1;
                white-space: nowrap;
            `;
            countdownElement.textContent = count;
            document.body.appendChild(countdownElement);

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownElement.textContent = count;
                    playSound('beep'); // 카운트다운 사운드
                } else {
                    countdownElement.textContent = '시작!';
                    playSound('success');
                    setTimeout(() => {
                        document.body.removeChild(countdownElement);
                        startGameAfterCountdown();
                    }, 500);
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        function startGameAfterCountdown() {
            gameState = 'SHOWING';
            stage = INITIAL_STAGE;
            lives = INITIAL_LIVES;
            sequenceSpeed = INITIAL_SEQUENCE_SPEED;
            timeLimit = INITIAL_TIME_LIMIT;
            
            // 모든 게임 관련 UI 요소들 표시
            timerContainer.classList.remove('opacity-0');
            progressContainer.classList.remove('opacity-0');
            messageBox.style.opacity = '1';
            stageDisplay.style.opacity = '1'; // 기억력 점수 표시 보이기
            livesContainer.style.opacity = '1'; // 생명 표시 보이기
            
            // 게임 진행 중 상태에서 소리 UI 보이기
            showVolumeControls();
            
            if (character) scene.remove(character);
            createCharacter();
            
            updateUI();
            
            bgm.volume = bgmVolumeSlider.value / 100;
            bgm.currentTime = 0;
            const playPromise = bgm.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log("Music auto-play was prevented. A user interaction is needed.");
                });
            }

            nextStage();
        }

        function calculateMemoryIndex(stage) {
            // 지수적 증가하되 적당한 기울기 (50 + 30 * (1.25^stage - 1))
            if (stage <= 0) return 50;
            
            const baseIndex = 50;
            const multiplier = 30; // 25에서 30으로 증가
            const growthRate = 1.25; // 1.2에서 1.25로 증가 (적당한 증가)
            
            const memoryScore = baseIndex + multiplier * (Math.pow(growthRate, stage) - 1);
            return Math.round(memoryScore);
        }

        function nextStage() {
            gameState = 'SHOWING';
            playerInput = [];
            const memoryScore = calculateMemoryIndex(stage);
            
            // 기억력 숫자에 zoom 효과 추가
            stageDisplay.classList.remove('iq-zoom');
            void stageDisplay.offsetWidth; // 강제 리플로우
            stageDisplay.textContent = `당신의 기억력은 아마도...`;
            stageDisplay.classList.add('iq-zoom');
            
            const keys = Object.keys(keywords);
            sequence = [];
            for (let i = 0; i < stage + 3; i++) {
                sequence.push(keys[Math.floor(Math.random() * keys.length)]);
            }
            showSequence();
        }

        function setupProgressIndicator() {
            progressContainer.innerHTML = '';
            for(let i=0; i<sequence.length; i++) {
                const dot = document.createElement('div');
                dot.className = 'progress-dot';
                progressContainer.appendChild(dot);
            }
        }
        
        async function showSequence() {
            // 게임 상태 확인
            if (gameState !== 'SHOWING') {
                console.log('showSequence: 게임 상태가 SHOWING이 아님:', gameState);
                return;
            }
            
            setupProgressIndicator();
            const dots = progressContainer.children;
            for (let i = 0; i < sequence.length; i++) {
                // 각 단계마다 게임 상태 확인
                if (gameState !== 'SHOWING') {
                    console.log('showSequence: 중간에 게임 상태 변경됨:', gameState);
                    return;
                }
                
                const key = sequence[i];
                await new Promise(resolve => setTimeout(resolve, sequenceSpeed));
                showMessage(keywords[key], key);
                playAnimation(key);
                if(dots[i]) {
                    dots[i].innerHTML = arrowIcons[key];
                    dots[i].style.backgroundColor = 'rgba(34, 197, 94, 0.9)'; // 초록색 배경
                    dots[i].style.color = 'white'; // 흰색 텍스트
                    dots[i].style.fontWeight = 'bold'; // 굵은 글씨
                    dots[i].style.fontSize = '24px'; // 큰 글씨
                }
            }
            await new Promise(resolve => setTimeout(resolve, sequenceSpeed));
            messageBox.className = messageBox.className.replace(/animate-\w+/g, '');
            messageBox.style.opacity = 0;

            // 최종 상태 확인 후 플레이어 턴 시작
            if (gameState === 'SHOWING') {
                startPlayerTurn();
            }
        }

        function startPlayerTurn() {
            // 게임 상태 확인
            if (gameState !== 'SHOWING') {
                console.log('startPlayerTurn: 게임 상태가 SHOWING이 아님:', gameState);
                return;
            }
            
            gameState = 'WAITING';
            playerInput = [];
            setupProgressIndicator(); // Reset indicators for player input
            startTimer();
        }

        function startTimer() {
            timerContainer.classList.remove('opacity-0');
            let timeLeft = timeLimit;
            timerBar.style.width = '100%';
            
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                // 타이머 실행 중에도 게임 상태 확인
                if (gameState !== 'WAITING') {
                    clearInterval(timerInterval);
                    return;
                }
                
                timeLeft -= 100;
                const widthPercentage = (timeLeft / timeLimit) * 100;
                timerBar.style.width = `${widthPercentage}%`;

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    handleIncorrectInput();
                }
            }, 100);
        }

        function handlePlayerInput(e) {
            if (gameState !== 'WAITING' || !keywords[e.key]) return;

            // 이미 시퀀스가 완료되었거나 잘못된 입력이 있었으면 추가 입력 무시
            if (playerInput.length >= sequence.length) return;

            playerInput.push(e.key);
            const currentKey = playerInput[playerInput.length - 1];
            const correctKey = sequence[playerInput.length - 1];
            
            const dots = progressContainer.children;

            if (currentKey !== correctKey) {
                if(dots[playerInput.length-1]) {
                    dots[playerInput.length-1].style.backgroundColor = 'rgba(239, 68, 68, 0.9)'; // 더 예쁜 빨간색
                    dots[playerInput.length-1].style.color = 'white'; // 흰색 텍스트
                    dots[playerInput.length-1].style.fontWeight = 'bold'; // 굵은 글씨
                    dots[playerInput.length-1].style.fontSize = '24px'; // 큰 글씨
                }
                handleIncorrectInput();
            } else {
                playAnimation(currentKey); // 플레이어 입력 시 캐릭터 움직임
                if(dots[playerInput.length-1]) {
                    dots[playerInput.length-1].innerHTML = arrowIcons[currentKey];
                    dots[playerInput.length-1].style.backgroundColor = 'rgba(34, 197, 94, 0.9)'; // 초록색 배경
                    dots[playerInput.length-1].style.color = 'white'; // 흰색 텍스트
                    dots[playerInput.length-1].style.fontWeight = 'bold'; // 굵은 글씨
                    dots[playerInput.length-1].style.fontSize = '24px'; // 큰 글씨
                }

                if (playerInput.length === sequence.length) {
                    handleCorrectSequence();
                }
            }
        }
        
        function handleIncorrectInput() {
            playSound('incorrect');
            clearInterval(timerInterval);
            timerContainer.classList.add('opacity-0');
            createWaterSplash();
            lives--;
            updateUI();
            if (lives <= 0) {
                gameOver();
            } else {
                // 게임 상태를 명확하게 설정
                gameState = 'SHOWING';
                playerInput = []; // 플레이어 입력 초기화
                setTimeout(() => {
                    messageBox.className = messageBox.className.replace(/animate-\w+/g, '');
                    messageBox.style.opacity = 0;
                    showSequence();
                }, 1500);
            }
        }

        function handleCorrectSequence() {
            clearInterval(timerInterval);
            timerContainer.classList.add('opacity-0');

            // 빵파레 효과 추가
            createConfetti();
            showMessage('성공!', null, '#FFD700'); // Gold
            stage++;
            // 난이도 상승
            sequenceSpeed = Math.max(200, sequenceSpeed - 20);
            timeLimit = Math.max(3000, timeLimit - 100);

            setTimeout(() => {
                 messageBox.className = messageBox.className.replace(/animate-\w+/g, '');
                 messageBox.style.opacity = 0;
                 nextStage();
            }, 1000);
        }

        function gameOver() {
            console.log('gameOver 함수 호출됨');
            bgm.pause();
            playSound('gameover');
            gameState = 'GAMEOVER';
            
            console.log('게임오버 화면 표시 시도');
            gameOverScreen.classList.remove('hidden');
            console.log('게임오버 화면 클래스:', gameOverScreen.className);
            
            // Dramatic Effect
            flashOverlay.style.opacity = '0.7';
            setTimeout(() => { flashOverlay.style.opacity = '0'; }, 100);
            shakeDuration = 0.5;
            
            // 5초 후 자동으로 최초화면으로 돌아가기
            setTimeout(() => {
                resetGame();
            }, 5000);
        }

        function showVolumeControls() {
            const volumeControls = document.getElementById('volume-controls');
            if (volumeControls) {
                volumeControls.style.display = 'flex';
            }
        }

        function hideVolumeControls() {
            const volumeControls = document.getElementById('volume-controls');
            if (volumeControls) {
                volumeControls.style.display = 'none';
            }
        }

        let uiVisible = true; // UI 표시 상태 추적

        function toggleGameUI() {
            uiVisible = !uiVisible;
            
            if (uiVisible) {
                // UI 보이기
                timerContainer.classList.remove('opacity-0');
                progressContainer.classList.remove('opacity-0');
                messageBox.style.opacity = '1';
                stageDisplay.style.opacity = '1';
                livesContainer.style.opacity = '1';
                showVolumeControls();
            } else {
                // UI 숨기기
                timerContainer.classList.add('opacity-0');
                progressContainer.classList.add('opacity-0');
                messageBox.style.opacity = '0';
                stageDisplay.style.opacity = '0';
                livesContainer.style.opacity = '0';
                hideVolumeControls();
            }
        }


        function createConfetti() {
            const confettiCount = 50;
            const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.style.cssText = `
                    position: fixed;
                    width: 10px;
                    height: 10px;
                    background-color: ${colors[Math.floor(Math.random() * colors.length)]};
                    top: 50%;
                    left: 50%;
                    pointer-events: none;
                    z-index: 1000;
                    border-radius: 2px;
                `;
                
                document.body.appendChild(confetti);
                
                const angle = Math.random() * Math.PI * 2;
                const velocity = 0.2 + Math.random() * 0.5; // 속도 더욱 감소 (0.5-1.5 → 0.2-0.7)
                const gravity = 0.02; // 중력 더욱 감소 (0.05 → 0.02)
                const rotation = Math.random() * 360;
                const rotationSpeed = (Math.random() - 0.5) * 1.5; // 회전 속도 더욱 감소 (3 → 1.5)
                
                let x = 0;
                let y = 0;
                let vx = Math.cos(angle) * velocity;
                let vy = Math.sin(angle) * velocity - 0.5; // 초기 수직 속도 더욱 감소 (-1 → -0.5)
                let currentRotation = rotation;
                
                const animateConfetti = () => {
                    x += vx;
                    y += vy;
                    vy += gravity;
                    currentRotation += rotationSpeed;
                    
                    confetti.style.left = `${50 + x}%`;
                    confetti.style.top = `${50 + y}%`;
                    confetti.style.transform = `rotate(${currentRotation}deg)`;
                    confetti.style.opacity = Math.max(0, 1 - Math.abs(y) / 200);
                    
                    if (y < 200 && confetti.parentNode) {
                        requestAnimationFrame(animateConfetti);
                    } else {
                        if (confetti.parentNode) {
                            confetti.parentNode.removeChild(confetti);
                        }
                    }
                };
                
                requestAnimationFrame(animateConfetti);
            }
        }

        function showMessage(text, key = null, color = '#FBBF24') {
            messageBox.textContent = text;
            messageBox.style.color = color;
            messageBox.style.opacity = 1;

            // Remove previous animation classes
            if (text === '성공!') {
                messageBox.className = "text-6xl md:text-8xl font-bold text-yellow-300"; // 성공 시 더 큰 글자
            } else {
                messageBox.className = "text-4xl md:text-6xl font-bold text-yellow-300"; // 기본 크기
            }
            void messageBox.offsetWidth;

            const vector = new THREE.Vector3(0, 1.6, 0); // 캐릭터 머리 위 기준점
            vector.project(camera);

            const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (vector.y * -0.5 + 0.5) * renderer.domElement.clientHeight;

            messageBox.style.left = `${x}px`;
            messageBox.style.top = `${y}px`;

            switch(key) {
                case 'ArrowUp':
                    messageBox.classList.add('animate-up');
                    break;
                case 'ArrowDown':
                    messageBox.classList.add('animate-down');
                    break;
                case 'ArrowLeft':
                    messageBox.classList.add('animate-left');
                    break;
                case 'ArrowRight':
                    messageBox.classList.add('animate-right');
                    break;
                default:
                    // For "Success" message, just fade in
                    messageBox.style.transform = 'translate(-50%, -50%)';
                    break;
            }
        }

        function updateUI() {
            const lifeElements = livesContainer.children;
            for(let i = 0; i < lifeElements.length; i++) {
                if (i < lives) {
                    lifeElements[i].classList.remove('lost');
                } else {
                    lifeElements[i].classList.add('lost');
                }
            }
            const memoryScore = calculateMemoryIndex(stage);
            
            // 기억력 숫자에 zoom 효과 추가
            stageDisplay.classList.remove('iq-zoom');
            void stageDisplay.offsetWidth; // 강제 리플로우
            stageDisplay.textContent = `당신의 올영력은 아마도... ${memoryScore} 정도?`;
            stageDisplay.classList.add('iq-zoom');
        }
        function resetGame() {
            startScreen.classList.remove('hidden');
            gameOverScreen.classList.add('hidden');
            gameState = 'START';
            lives = 3;
            stage = 1;
            
            // 모든 게임 관련 UI 요소들 숨기기
            timerContainer.classList.add('opacity-0');
            progressContainer.classList.add('opacity-0');
            messageBox.style.opacity = '0';
            stageDisplay.style.opacity = '0'; // 기억력 점수 표시 숨기기
            livesContainer.style.opacity = '0'; // 생명 표시 숨기기
            
            // 음악, 소리 UI 숨기기 (게임오버 후 다시도전 상태)
            hideVolumeControls();
            
            // 걸어다니기 중단
            isWalking = false;
            walkAnimationTimer = 0;
            lastIdleAction = 0;
            
            // 캐릭터를 원래 자리로 리셋
            if (character) {
                character.position.set(0, 0.5, 0);
                character.rotation.y = 0;
                character.scale.set(1, 1, 1);
            }
            
            updateUI();
            
            // 게임 리셋 후 걸어다니기 시작 (최초 초기화와 동일)
            setTimeout(() => {
                if (gameState === 'START') {
                    startWalking();
                }
            }, 1000);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        startButton.addEventListener('click', startGame);
        retryButton.addEventListener('click', resetGame);
        
        bgmVolumeSlider.addEventListener('input', (e) => {
            bgm.volume = e.target.value / 100;
        });

        sfxVolumeSlider.addEventListener('input', (e) => {
            sfxVolume = e.target.value / 100;
        });

        window.addEventListener('keydown', handlePlayerInput);
        window.addEventListener('resize', () => {
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        });
        window.addEventListener('mousemove', onMouseMove);
        
        // 화살표 버튼 클릭 이벤트 추가
        document.querySelectorAll('.key-indicator[data-key]').forEach(button => {
            button.addEventListener('click', (e) => {
                const key = e.currentTarget.getAttribute('data-key');
                // 키보드 이벤트와 동일한 이벤트 객체 생성
                const keyEvent = new KeyboardEvent('keydown', {
                    key: key,
                    code: key,
                    keyCode: key === 'ArrowUp' ? 38 : key === 'ArrowDown' ? 40 : key === 'ArrowLeft' ? 37 : 39,
                    which: key === 'ArrowUp' ? 38 : key === 'ArrowDown' ? 40 : key === 'ArrowLeft' ? 37 : 39,
                    bubbles: true,
                    cancelable: true
                });
                handlePlayerInput(keyEvent);
            });
        });

        init3D();
        document.getElementById('start-button').classList.add('pulsing');
        
        // 게임 대기상태에서 하트와 볼륨 UI 숨기기
        livesContainer.style.opacity = '0';
        hideVolumeControls();
        
        // 초기 슬라이더 값 설정
        bgmVolumeSlider.value = BGM_DEFAULT_VOLUME;
        sfxVolumeSlider.value = SFX_DEFAULT_VOLUME;

    </script>
</body>
</html>

