<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>기억력 챌린지</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // redi 중복 로드 경고 무시
        (function() {
            if (window.console) {
                const originalWarn = window.console.warn;
                const originalError = window.console.error;
                
                window.console.warn = function(...args) {
                    const message = args.join(' ');
                    if (message.includes('redi') || message.includes('redi]')) {
                        return; // redi 관련 경고 무시
                    }
                    originalWarn.apply(console, args);
                };
                
                window.console.error = function(...args) {
                    const message = args.join(' ');
                    if (message.includes('redi') || message.includes('redi]')) {
                        return; // redi 관련 에러 무시
                    }
                    originalError.apply(console, args);
                };
            }
        })();
    </script>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'IBM Plex Sans KR', sans-serif;
            overflow: hidden;
            background-color: #87CEEB; /* 하늘색 배경 */
            touch-action: manipulation; /* 터치 확대 방지 */
            -webkit-touch-callout: none; /* iOS 터치 콜아웃 방지 */
            -webkit-user-select: none; /* 텍스트 선택 방지 */
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* UI가 3D 뷰를 가리지 않도록 */
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: auto; /* 오버레이 내 버튼 등은 클릭 가능하도록 */
        }
        #message-box {
            position: absolute;
            opacity: 0; /* 기본적으로 숨김 */
        }
        .key-indicator {
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 0.8rem;
            padding: 1rem 1.5rem;
            color: white;
            font-weight: bold;
            font-size: 1.4rem;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s ease;
        }
        
        .key-indicator:hover {
            background-color: rgba(0, 0, 0, 0.7);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .key-indicator:active {
            transform: scale(0.95);
        }
        .life {
            width: 40px;
            height: 40px;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24" fill="red"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>');
            background-size: contain;
            background-repeat: no-repeat;
            transition: transform 0.2s ease-in-out;
        }
        .life.lost {
            transform: scale(0);
        }
        .timer-bar {
            height: 10px;
            background-color: #4CAF50;
            border-radius: 5px;
            transition: width 0.1s linear;
        }
        #progress-container {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .progress-dot {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border: 3px solid rgba(34, 197, 94, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(34, 197, 94, 0.8);
            font-size: 32px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        /* 텍스트 애니메이션 */
        @keyframes slide-up {
            from { opacity: 0; transform: translate(-50%, -250%) scale(0.4); }
            to { opacity: 1; transform: translate(-50%, -320%) scale(1); }
        }
        .animate-up { animation: slide-up 0.3s ease-out forwards; }

        @keyframes slide-down {
            from { opacity: 0; transform: translate(-50%, 200%) scale(0.4); }
            to { opacity: 1; transform: translate(-50%, 450%) scale(1); }
        }
        .animate-down { animation: slide-down 0.3s ease-out forwards; }

        @keyframes slide-left {
            from { opacity: 0; transform: translate(-80%, 20%) scale(0.4); }
            to { opacity: 1; transform: translate(-160%, 20%) scale(1); }
        }
        .animate-left { animation: slide-left 0.3s ease-out forwards; }

        @keyframes slide-right {
            from { opacity: 0; transform: translate(0%, 20%) scale(0.4); }
            to { opacity: 1; transform: translate(60%, 20%) scale(1); }
        }
        .animate-right { animation: slide-right 0.3s ease-out forwards; }


        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        #start-button.pulsing {
             animation: pulse 2s infinite;
        }
        #flash-overlay {
            transition: opacity 0.1s ease-out;
        }
        #volume-controls {
            pointer-events: auto;
        }
        
        /* 플랫한 세로 슬라이더 */
        .slider-flat {
            -webkit-appearance: none;
            appearance: none;
            background: #333;
            outline: none;
            border: none;
            border-radius: 2px;
            writing-mode: bt-lr; /* IE */
            -webkit-appearance: slider-vertical; /* WebKit */
            transition: background-color 0.2s ease;
        }
        
        .slider-flat:hover {
            background: #444;
        }
        
        .slider-flat::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #333;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .slider-flat::-webkit-slider-thumb:hover {
            background: #f0f0f0;
            border-color: #555;
        }
        
        .slider-flat::-webkit-slider-thumb:active {
            background: #e0e0e0;
            transform: scale(0.95);
        }
        
        .slider-flat::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #fff;
            border: 2px solid #333;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .slider-flat::-moz-range-thumb:hover {
            background: #f0f0f0;
            border-color: #555;
        }
        
        /* Firefox에서 세로 슬라이더 지원 */
        .slider-flat[orient="vertical"] {
            writing-mode: bt-lr;
            -webkit-appearance: slider-vertical;
        }
        
        /* IQ 숫자 zoom 효과 */
        .iq-zoom {
            animation: iqZoom 0.6s ease-in-out;
        }
        
        @keyframes iqZoom {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        /* 말풍선 스타일 */
        .speech-bubble {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.95);
            color: #333;
            padding: 8px 12px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid #4169E1;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 100;
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
            transition: all 0.3s ease;
            max-width: 120px;
            text-align: center;
            pointer-events: none;
        }
        
        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-top: 8px solid #4169E1;
        }
        
        .speech-bubble.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* 반응형 디자인 */
        @media (max-width: 768px) {
            /* 모바일 화면 */
            .key-indicator {
                font-size: 1rem;
                padding: 0.8rem 1rem;
                min-height: 50px;
            }
            
            #start-button, #how-to-play-button {
                font-size: 1.5rem;
                padding: 0.75rem 1.5rem;
            }
            
            .overlay h1 {
                font-size: 2.5rem !important;
            }
            
            .overlay p {
                font-size: 1rem !important;
            }
            
            /* 화살표 UI 모바일 최적화 */
            #key-indicators .key-indicator {
                font-size: 0.9rem;
                padding: 0.6rem 0.8rem;
                min-height: 45px;
            }
        }

        @media (max-width: 480px) {
            /* 작은 모바일 화면 */
            .key-indicator {
                font-size: 0.9rem;
                padding: 0.6rem 0.8rem;
                min-height: 40px;
            }
            
            #start-button, #how-to-play-button {
                font-size: 1.25rem;
                padding: 0.6rem 1.2rem;
            }
            
            .overlay h1 {
                font-size: 2rem !important;
            }
            
            .overlay p {
                font-size: 0.9rem !important;
            }
            
            /* 화살표 UI 더 작게 */
            #key-indicators .key-indicator {
                font-size: 0.8rem;
                padding: 0.5rem 0.6rem;
                min-height: 35px;
            }
        }

        /* 터치 이벤트 최적화 */
        * {
            -webkit-tap-highlight-color: transparent;
        }

        button, .key-indicator {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
    </style>
</head>
<body class="bg-gray-800 text-white">

    <div id="game-container">
        <!-- 3D 렌더링이 이루어질 캔버스. 두근-->
        <div id="canvas-container" class="w-full h-full"></div>
        
        <div id="flash-overlay" class="absolute inset-0 bg-red-500 opacity-0 pointer-events-none"></div>

        <!-- 게임 UI -->
        <div id="ui-layer">
             <!-- 상단 UI: 스테이지, 라이프 -->
            <div class="w-full flex justify-between items-center p-4 md:p-8">
                <h1 id="stage-display" class="text-2xl md:text-4xl font-bold text-white" style="text-shadow: 2px 2px 4px #000000;"></h1>
                <div id="lives-container" class="flex space-x-2">
                    <div class="life"></div>
                    <div class="life"></div>
                    <div class="life"></div>
                </div>
            </div>
            
            <!-- 진행상황ㅇ 표시 -->
            <div id="progress-container"></div>

            <!-- 중앙: 캐릭터 멘트 -->
            <div id="message-box" class="text-6xl md:text-8xl font-bold text-yellow-300" style="text-shadow: 3px 3px 6px #000000;"></div>
            
            <!-- 말풍선 -->
            <div id="speech-bubble" class="speech-bubble"></div>
            <!-- // 하단 UI: 타이머 -->
            <div class="absolute bottom-0 left-0 right-0 w-full flex flex-col items-center space-y-4 p-4 md:p-8">
                 <div id="timer-container" class="w-full max-w-md bg-gray-700 rounded-full overflow-hidden opacity-0">
                    <div id="timer-bar" class="timer-bar"></div>
                </div>
            </div>

            <!-- 좌측 하단: 볼륨 조절 -->
            <div id="volume-controls" class="absolute bottom-4 left-4 flex space-x-6 bg-black bg-opacity-70 p-6 rounded-xl backdrop-blur-sm border border-white border-opacity-30">
                <!-- 배경음악 -->
                <div class="flex flex-col items-center space-y-3">
                    <div class="flex flex-col items-center space-y-1">
                        <span class="text-white text-sm font-semibold">음악</span>
                    </div>
                    <div class="relative">
                        <input type="range" id="bgm-volume" min="0" max="100" class="w-4 h-32 appearance-none cursor-pointer slider-flat" orient="vertical">
                    </div>
                </div>
                
                <!-- 효과음 -->
                <div class="flex flex-col items-center space-y-3">
                    <div class="flex flex-col items-center space-y-1">
                        <span class="text-white text-sm font-semibold">소리</span>
                    </div>
                    <div class="relative">
                        <input type="range" id="sfx-volume" min="0" max="100" class="w-4 h-32 appearance-none cursor-pointer slider-flat" orient="vertical">
                    </div>
                </div>
            </div>

            <!-- 우측 하단: 화살표 버튼 (게임 중에만 표시) -->
            <div id="key-indicators" class="absolute bottom-4 right-4 pointer-events-auto hidden">
                <!-- 화살표 방향에 맞는 배열 -->
                <div class="flex flex-col items-center space-y-2">
                    <!-- 위쪽 화살표 -->
                    <button class="key-indicator hover:bg-opacity-80 transition-all duration-200 transform hover:scale-105 active:scale-95 cursor-pointer" data-key="ArrowUp">↑ 트렌드리딩</button>
                    
                    <!-- 좌우 화살표 -->
                    <div class="flex space-x-4">
                        <button class="key-indicator hover:bg-opacity-80 transition-all duration-200 transform hover:scale-105 active:scale-95 cursor-pointer" data-key="ArrowLeft">← 협업,소통</button>
                        <button class="key-indicator hover:bg-opacity-80 transition-all duration-200 transform hover:scale-105 active:scale-95 cursor-pointer" data-key="ArrowRight">→ 함께성장</button>
                    </div>
                    
                    <!-- 아래쪽 화살표 -->
                    <button class="key-indicator hover:bg-opacity-80 transition-all duration-200 transform hover:scale-105 active:scale-95 cursor-pointer" data-key="ArrowDown">↓ 강한실행력</button>
                </div>
            </div>
        </div>

        <!-- 1차 대기화면 (메인 화면) -->
        <div id="start-screen" class="overlay absolute inset-0 flex flex-col justify-end items-center text-center p-4">
            <button id="start-button" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-4 px-12 rounded-lg text-2xl transition-transform transform hover:scale-105 mb-20">게임 시작하기</button>
        </div>

        <!-- 2차 대기화면 (How to Play) -->
        <div id="how-to-play-screen" class="overlay absolute inset-0 bg-black bg-opacity-70 flex flex-col justify-center items-center text-center p-4 hidden">
            <h1 class="text-5xl md:text-7xl font-bold mb-4">올영력 챌린지!</h1>
            <p class="text-lg md:text-xl mb-8 max-w-2xl">
            올리브영의 일하는 방식 구호에 맞춰 키보드 화살표가 눌러집니다. <br>동작을 차례대로 기억해 두었다가, 구호가 모두 끝나면 키보드를 순서대로 눌러 따라해주세요!</p>
            <button id="how-to-play-button" class="bg-green-500 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-2xl transition-transform transform hover:scale-105">시작하기</button>
        </div>

        <!-- 게임 오버 화면 -->

        <div id="game-over-screen" class="overlay absolute inset-0 bg-black bg-opacity-70 flex flex-col justify-center items-center text-center p-4 hidden">
            <h1 class="text-6xl md:text-8xl font-bold mb-4">게임 오버!!</h1>
            <button id="retry-button" class="bg-green-500 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg text-2xl transition-transform transform hover:scale-105">다시 도전</button>
        </div>
    </div>
    
    
    <audio id="bgm" loop src="Pixel Dreams.mp3"></audio>

    <script>
    
        const INITIAL_LIVES = 3;
        const INITIAL_STAGE = 1;
        const INITIAL_SEQUENCE_SPEED = 800; // ms, 숫자가 작을수록 빨라짐
        const INITIAL_TIME_LIMIT = 5000;    // ms, 플레이어 입력 시간
        const SHAKE_INTENSITY = 0.1;        // 게임 오버 시 화면 흔들림 강도
        
        // --- 사운드 설정 ---
        const BGM_DEFAULT_VOLUME = 50; // 배경음악 초기 볼륨 (0-100)
        const SFX_DEFAULT_VOLUME = 80; // 효과음 초기 볼륨 (0-100)
        
        // --- 설정 끝 ---


        // --- THREE.js 셋업 ---
        let scene, camera, renderer, character, clock;
        let waterParticles = [];
        let birds = [];
        let hotAirBalloons = [];
        const canvasContainer = document.getElementById('canvas-container');
        let mouse = new THREE.Vector2();

        const keywords = {
            'ArrowUp': '↑ 트렌드리딩',
            'ArrowDown': '↓ 강한실행력',
            'ArrowLeft': '← 협업,소통',
            'ArrowRight': '→ 함께성장'
        };
        const arrowIcons = {
            'ArrowUp': '↑',
            'ArrowDown': '↓',
            'ArrowLeft': '←',
            'ArrowRight': '→'
        };

        // --- 게임 상태 변수 ---
        let gameState = 'START'; // START, SHOWING, WAITING, GAMEOVER
        let sequence = [];
        let playerInput = [];
        let stage;
        let lives;
        let sequenceSpeed;

        // --- NPC 관련 변수 ---
        let npcCharacters = [];
        let npcSpawnTimer = 0;
        let npcSpawnInterval = 300000; // 5분 (300초)
        let maxNpcs = 1; // 최대 NPC 수
        let isFirstNPCSpawned = false; // 첫 번째 NPC 스폰 여부
        let timeLimit;
        let timerInterval;
        let shakeDuration = 0;
        let gameOverTimeout; // 게임 오버 후 자동 리셋 타이머

        // --- UI 요소 ---
        const stageDisplay = document.getElementById('stage-display');
        const livesContainer = document.getElementById('lives-container');
        const messageBox = document.getElementById('message-box');
        const startScreen = document.getElementById('start-screen');
        const howToPlayScreen = document.getElementById('how-to-play-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const startButton = document.getElementById('start-button');
        const howToPlayButton = document.getElementById('how-to-play-button');
        const retryButton = document.getElementById('retry-button');
        const keyIndicators = document.getElementById('key-indicators');
        const timerContainer = document.getElementById('timer-container');
        const timerBar = document.getElementById('timer-bar');
        const progressContainer = document.getElementById('progress-container');
        const flashOverlay = document.getElementById('flash-overlay');
        const bgm = document.getElementById('bgm');
        const bgmVolumeSlider = document.getElementById('bgm-volume');
        const sfxVolumeSlider = document.getElementById('sfx-volume');
        const speechBubble = document.getElementById('speech-bubble');
        
        // 말풍선 관련 변수 - 올리브영 일하는 방식 공식 메시지
        const speechMessages = [
            // 올리브영 공식 일하는 방식
            "고객의 '건강한 아름다움, 일상 속의 새로움'이 우리의 시작과 끝!",
            "와! 이걸 한다고? 이게 된다고?! 새로운 시도로 새로운 길을 만들어볼까",
            "고객과 시장보다 반 발짝 앞서야지!",
            "공감은 충분히, 실행은 빠르게!",
            "회의와 보고의 목적은 바로 뭐다? 바로 결론이다.",
            "어제의 방식이 오늘의 정답은 아니다...",
            "협업은 도와주는 것이 아니라 결과를 같이 만들어 나가는 것...",
            "Role + Responsibility, 역할은 권한이 아니라 책임이야",
            
            // 추가 메시지
            "문제와 이슈는 숨기지 말고, 수면 위로 올려 함께 답을 찾는거야.",
            "내 랩을 들어봐: '내 일!'을 통해, 내일 더 성장!",
            "우리는 서로에게 '배우고 싶은 동료'가 된다!!",
            "올리브영을 사랑하는 우리? 우리가 앞으로의 올리브영을 만드는거래 ㅎㅎ",
            
            // 추가 인사 및 격려
            "안녕!", "반가워!", "화이팅!", "오늘도 올영력 충전!",
            "함께 성장해요!", "뷰티가 최고!", "건강이 우선!",
            
            // 글로벌IT개발센터 & 세계정복
            "글로벌IT개발센터 화이팅!!", "올리브영 세.계.정.복."
        ];
        let speechTimer = 0;
        let speechCooldown = 0;
        let isSpeechActive = false;
        
        // Web Audio API context
        let audioCtx;
        let sfxVolume = SFX_DEFAULT_VOLUME / 100;

        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, 4, 5);
            camera.lookAt(0, 0.5, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            canvasContainer.appendChild(renderer.domElement);
            
            clock = new THREE.Clock();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.4; // 땅을 아래로 내림
            ground.receiveShadow = true;
            scene.add(ground);

            createFoliage();
            createClouds();
            createBirds();
            createHotAirBalloons();
            createCharacter();
            
            // 게임 초기화 시점부터 걸어다니기 시작
            setTimeout(() => {
                if (gameState === 'START') {
                    startWalking();
                    speechCooldown = 3000; // 3초 후부터 말풍선 시작
                }
            }, 1000);
            
            animate();
        }
        
        function createHotAirBalloons() {
            for (let i = 0; i < 8; i++) {
                const balloonGroup = new THREE.Group();
                const balloonGeo = new THREE.SphereGeometry(1.5, 16, 16);
                const balloonMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(Math.random(), Math.random(), Math.random()) });
                const balloon = new THREE.Mesh(balloonGeo, balloonMat);

                const basketGeo = new THREE.BoxGeometry(0.8, 0.6, 0.8);
                const basketMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const basket = new THREE.Mesh(basketGeo, basketMat);
                basket.position.y = -1.8;

                balloonGroup.add(balloon);
                balloonGroup.add(basket);

                balloonGroup.position.set(
                    (Math.random() - 0.5) * 60,
                    Math.random() * 8 + 5,
                    (Math.random() - 0.5) * 40 - 25
                );
                scene.add(balloonGroup);
                hotAirBalloons.push(balloonGroup);
            }
        }


        function createFoliage() {
            const flowerColors = [0xff69b4, 0xffff00, 0xffffff];
            const foliageGroup = new THREE.Group();
            const grassGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 5);
            const grassMat = new THREE.MeshStandardMaterial({ color: 0x008000 });
            for(let i = 0; i < 300; i++) {
                const grass = new THREE.Mesh(grassGeo, grassMat);
                const x = (Math.random() - 0.5) * 50;
                const z = (Math.random() - 0.5) * 50;
                grass.position.set(x, -0.25, z); // 잔디를 땅과 함께 아래로 내림
                grass.rotation.x = (Math.random() - 0.5) * 0.2;
                grass.rotation.z = (Math.random() - 0.5) * 0.2;
                foliageGroup.add(grass);
            }
            const stemGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.5, 5);
            const stemMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
            const petalGeo = new THREE.SphereGeometry(0.1, 8, 8);
            for(let i = 0; i < 50; i++) {
                const flower = new THREE.Group();
                const stem = new THREE.Mesh(stemGeo, stemMat);
                const petalMat = new THREE.MeshStandardMaterial({ color: flowerColors[Math.floor(Math.random()*flowerColors.length)] });
                const petal = new THREE.Mesh(petalGeo, petalMat);
                petal.position.y = 0.25;
                flower.add(stem);
                flower.add(petal);
                const x = (Math.random() - 0.5) * 50;
                const z = (Math.random() - 0.5) * 50;
                flower.position.set(x, -0.15, z); // 꽃
                foliageGroup.add(flower);
            }
            scene.add(foliageGroup);
        }

        function createClouds() {
            const cloudGeo = new THREE.SphereGeometry(1, 8, 8);
            const cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            for (let i = 0; i < 10; i++) {
                const cloud = new THREE.Group();
                for (let j = 0; j < 5; j++) {
                    const part = new THREE.Mesh(cloudGeo, cloudMat);
                    part.position.set((Math.random() - 0.5) * 3, (Math.random() - 0.5) * 1, (Math.random() - 0.5) * 1);
                    part.scale.setScalar(Math.random() * 0.5 + 0.5);
                    cloud.add(part);
                }
                cloud.position.set((Math.random() - 0.5) * 80, Math.random() * 5 + 10, (Math.random() - 0.5) * 80 - 30);
                scene.add(cloud);
            }
        }

        function createBirds() {
            const birdGeo = new THREE.BoxGeometry(0.3, 0.05, 0.1);
            const birdMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
            for (let i = 0; i < 5; i++) {
                const bird = new THREE.Group();
                const wing1 = new THREE.Mesh(birdGeo, birdMat);
                wing1.position.x = -0.15;
                const wing2 = new THREE.Mesh(birdGeo, birdMat);
                wing2.position.x = 0.15;
                bird.add(wing1);
                bird.add(wing2);
                bird.position.set((Math.random() - 0.5) * 100, Math.random() * 5 + 12, (Math.random() - 0.5) * 40 - 40);
                bird.velocity = new THREE.Vector3(Math.random() * 2 + 2, 0, 0);
                scene.add(bird);
                birds.push(bird);
            }
        }
        
        function showSpeechBubble() {
            if (!character || isSpeechActive) return;
            
            // 랜덤 메시지 선택
            const randomMessage = speechMessages[Math.floor(Math.random() * speechMessages.length)];
            
            // 기존 3D 말풍선이 있다면 제거
            if (character.speechBubble3D) {
                character.remove(character.speechBubble3D);
            }
            
            // 새로운 3D 8bit 말풍선 생성
            const speechBubble3D = create3DSpeechBubble(randomMessage);
            speechBubble3D.position.set(0, 1.8, 0); // 캐릭터 머리 위
            
            // 말풍선이 항상 카메라를 바라보도록 설정
            speechBubble3D.lookAt(camera.position);
            
            character.add(speechBubble3D);
            character.speechBubble3D = speechBubble3D;
            
            isSpeechActive = true;
            
            // 5초 후 말풍선 숨기기
            setTimeout(() => {
                if (character.speechBubble3D) {
                    character.remove(character.speechBubble3D);
                    character.speechBubble3D = null;
                }
                isSpeechActive = false;
                speechCooldown = 5000; // 5초 쿨다운 시작
            }, 5000);
        }
        
        function updateSpeechBubble(delta) {
            if (!character) return;
            
            // 3D 말풍선이 활성화되어 있으면 카메라를 바라보도록 업데이트
            if (isSpeechActive && character.speechBubble3D) {
                character.speechBubble3D.lookAt(camera.position);
            }
            
            // 쿨다운 업데이트
            if (speechCooldown > 0) {
                speechCooldown -= delta * 1000;
                if (speechCooldown <= 0) {
                    // 쿨다운 끝나면 랜덤하게 말풍선 표시
                    if (Math.random() < 0.3 && gameState === 'START') { // 30% 확률로 말풍선 표시
                        showSpeechBubble();
                    } else {
                        speechCooldown = 2000; // 2초 후 다시 시도
                    }
                }
            }
        }
        
        function addLogoToCanvas(context, width, height) {
            // 로고 이미지 로드 및 그리기
            const logoImg = new Image();
            logoImg.onload = function() {
                // 로고 크기 (캔버스의 8% 크기로 더 작게)
                const logoSize = Math.min(width, height) * 0.08;
                
                // 상단 우측 위치 (마진 포함) - 위로 더 올림
                const marginX = width * 0.05; // 좌우 마진 5%
                const marginY = height * 0.02; // 상하 마진을 5%에서 2%로 줄여서 더 위로
                const logoX = width - logoSize - marginX;
                const logoY = marginY;
                
                // 로고 그리기
                context.drawImage(logoImg, logoX, logoY, logoSize, logoSize);
            };
            logoImg.src = 'olivelogo.png';
        }
        
        function createShirtWithLogo(text, width = 256, height = 512) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const context = canvas.getContext('2d');
            
            // 올리브영 RoyalBlue 배경
            context.fillStyle = '#4169E1'; // RoyalBlue
            context.fillRect(0, 0, width, height);
            
            // 글자 스타일 - 
            context.font = `Bold ${width * 0.2}px 'IBM Plex Sans KR'`;
            context.fillStyle = 'white';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // 글자를 세로로 더 길게 만들기 위해 scaleX 적용
            context.save();
            context.scale(0.8, 1); // X축을 70%로 축소하여 세로로 길게
            context.fillText(text, width / 2 / 0.7, height / 2); // scaleX 보정
            context.restore();

            // 로고를 상단 우측에 추가
            // addLogoToCanvas(context, width, height);

            const texture = new THREE.CanvasTexture(canvas);
            return new THREE.MeshStandardMaterial({ map: texture, roughness: 0.8, metalness: 0.1 });
        }

        function createBadge() {
            // 명찰용 재질 생성
            const textureLoader = new THREE.TextureLoader();
            const badgeMaterial = new THREE.MeshStandardMaterial({
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.1,
                transparent: true,
                alphaTest: 0.1
            });
            
            return { material: badgeMaterial, textureLoader: textureLoader };
        }
        
        function create3DSpeechBubble(text) {
            const speechGroup = new THREE.Group();
            
            // 임시 캔버스로 텍스트 크기 측정
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');
            tempContext.font = 'bold 26px monospace'; // 폰트 크기 22px → 26px로 증가
            
            // 텍스트를 여러 줄로 나누고 최대 너비 계산
            const maxLineWidth = 450; // 최대 라인 너비 증가
            const words = text.split(' ');
            let lines = [];
            let currentLine = '';
            let maxWidth = 0;
            
            words.forEach(word => {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = tempContext.measureText(testLine);
                if (metrics.width > maxLineWidth && currentLine) {
                    lines.push(currentLine);
                    maxWidth = Math.max(maxWidth, tempContext.measureText(currentLine).width);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            if (currentLine) {
                lines.push(currentLine);
                maxWidth = Math.max(maxWidth, tempContext.measureText(currentLine).width);
            }
            
            // 동적 크기 계산 (마진 증가)
            const padding = 80; // 패딩 40px → 80px로 증가
            const lineHeight = 28; // 라인 높이 22px → 28px로 증가
            const canvasWidth = Math.max(250, maxWidth + padding);
            const canvasHeight = Math.max(120, lines.length * lineHeight + padding);
            
            // 3D 말풍선 크기도 동적으로 조정
            const bubbleWidth = canvasWidth / 200; // 기본 200px 기준으로 스케일링
            const bubbleHeight = canvasHeight / 200;
            
            // 8bit 픽셀 스타일 말풍선 배경 (동적 크기)
            const bubbleGeo = new THREE.PlaneGeometry(bubbleWidth, bubbleHeight);
            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const context = canvas.getContext('2d');
            
            // 픽셀 아트 느낌을 위해 이미지 스무딩 끄기
            context.imageSmoothingEnabled = false;
            
            // 8bit 스타일 말풍선 그리기
            const pixelSize = 8;
            
            // 외곽 테두리 (검은색 픽셀)
            context.fillStyle = '#000000';
            for (let x = 0; x < canvas.width; x += pixelSize) {
                for (let y = 0; y < canvas.height; y += pixelSize) {
                    if (x < pixelSize * 2 || x >= canvas.width - pixelSize * 2 || 
                        y < pixelSize * 2 || y >= canvas.height - pixelSize * 2) {
                        context.fillRect(x, y, pixelSize, pixelSize);
                    }
                }
            }
            
            // 내부 배경 (흰색)
            context.fillStyle = '#FFFFFF';
            context.fillRect(pixelSize * 2, pixelSize * 2, 
                           canvas.width - pixelSize * 4, canvas.height - pixelSize * 4);
            
            // 8bit 스타일 텍스트
            context.fillStyle = '#000000';
            context.font = 'bold 26px monospace'; // 폰트 크기 증가
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // 여러 줄 텍스트 그리기
            const startY = canvas.height / 2 - ((lines.length - 1) * lineHeight) / 2;
            
            lines.forEach((line, index) => {
                context.fillText(line, canvas.width / 2, startY + index * lineHeight);
            });
            
            const bubbleTexture = new THREE.CanvasTexture(canvas);
            bubbleTexture.magFilter = THREE.NearestFilter; // 픽셀 아트 느낌 유지
            bubbleTexture.minFilter = THREE.NearestFilter;
            
            const bubbleMaterial = new THREE.MeshBasicMaterial({ 
                map: bubbleTexture, 
                transparent: true,
                alphaTest: 0.1
            });
            
            const bubble = new THREE.Mesh(bubbleGeo, bubbleMaterial);
            bubble.position.y = 0.4;
            speechGroup.add(bubble);
            
            // 8bit 스타일 꼬리 (픽셀 삼각형)
            const tailGeo = new THREE.PlaneGeometry(0.5, 0.5);
            const tailCanvas = document.createElement('canvas');
            tailCanvas.width = 100;
            tailCanvas.height = 100;
            const tailContext = tailCanvas.getContext('2d');
            tailContext.imageSmoothingEnabled = false;
            
            // 배경을 투명하게 초기화
            tailContext.clearRect(0, 0, 100, 100);
            
            // 픽셀 삼각형 꼬리 그리기 (더 큰 삼각형)
            const tailPixelSize = 10;
            
            // 외곽 테두리 (검은색)
            const triangleOutline = [
                [4, 2], [5, 2], // 최상단
                [3, 3], [4, 3], [5, 3], [6, 3], // 두번째 줄
                [2, 4], [3, 4], [4, 4], [5, 4], [6, 4], [7, 4], // 세번째 줄
                [3, 5], [4, 5], [5, 5], [6, 5], // 네번째 줄
                [4, 6], [5, 6], // 하단
            ];
            
            tailContext.fillStyle = '#000000';
            triangleOutline.forEach(([x, y]) => {
                tailContext.fillRect(x * tailPixelSize, y * tailPixelSize, tailPixelSize, tailPixelSize);
            });
            
            // 내부 (흰색)
            const triangleInner = [
                [4, 3], [5, 3], // 내부 상단
                [3, 4], [4, 4], [5, 4], [6, 4], // 내부 중간
                [4, 5], [5, 5], // 내부 하단
            ];
            
            tailContext.fillStyle = '#FFFFFF';
            triangleInner.forEach(([x, y]) => {
                tailContext.fillRect(x * tailPixelSize, y * tailPixelSize, tailPixelSize, tailPixelSize);
            });
            
            const tailTexture = new THREE.CanvasTexture(tailCanvas);
            tailTexture.magFilter = THREE.NearestFilter;
            tailTexture.minFilter = THREE.NearestFilter;
            
            const tailMaterial = new THREE.MeshBasicMaterial({ 
                map: tailTexture, 
                transparent: true,
                alphaTest: 0.1
            });
            const tail = new THREE.Mesh(tailGeo, tailMaterial);
            tail.position.set(0, -0.1, 0.01); // 말풍선 아래쪽에 위치
            speechGroup.add(tail);
            
            return speechGroup;
        }


        function createCharacter() {
            character = new THREE.Group();
            scene.add(character);
            character.position.y = 0.5;
            character.rotation.y = 0; // 캐릭터가 항상 카메라를 보도록 고정
            
            const characterMaterial = new THREE.MeshStandardMaterial({ roughness: 0.8, metalness: 0.1 });
            const isFemale = Math.random() > 0.5;
            const skinColor = 0xFFDAB9;
            const pantsColor = 0x464646;
            
            // Minecraft 스타일 머리 - 각 면마다 다른 색상
            const headGeo = new THREE.BoxGeometry(0.8, 0.8, 0.6);
            const hairColor = 0x3b2219; // 머리카락색
            
            // 머리 재질 배열 - 앞면은 살색, 나머지는 머리카락색
            const headMaterials = [
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 }), // right - 머리카락색
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 }), // left - 머리카락색
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 }), // top - 머리카락색
                new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 }), // bottom - 머리카락색
                new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 }), // back - 머리카락색
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 })  // front - 살색 (얼굴)
            ];
            
            const head = new THREE.Mesh(headGeo, headMaterials);
            head.castShadow = true;
            head.position.y = 0.6;
            character.add(head);
            character.head = head;

            // 얼굴 요소들 - 살색 앞면에 그리기


            const faceComponentsZ = 0.301 

            // 이마 헤어
            const foreheadHairGeo = new THREE.BoxGeometry(0.8, 0.3, 0.01);
            const foreheadHairMaterial = new THREE.MeshBasicMaterial({ color: hairColor });
            const foreheadHair = new THREE.Mesh(foreheadHairGeo, foreheadHairMaterial);
            foreheadHair.position.set(0, 0.3, faceComponentsZ); // 이마 부분에 배치
            head.add(foreheadHair);
            character.foreheadHair = foreheadHair;
            

            // 눈
            const eyeGeo = new THREE.BoxGeometry(0.1, 0.15, 0.00);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: '#241478' }); // Dark Blue
            const leftEye = new THREE.Mesh(eyeGeo, eyeMaterial.clone());
            leftEye.position.set(0.15, -0.02, faceComponentsZ); // 살색 앞면에 배치
            head.add(leftEye);
            character.leftEye = leftEye;

            const rightEye = new THREE.Mesh(eyeGeo, eyeMaterial.clone());
            rightEye.position.set(-0.15, -0.02, faceComponentsZ); // 살색 앞면에 배치
            head.add(rightEye);
            character.rightEye = rightEye;
            
            // 코
            const noseGeo = new THREE.BoxGeometry(0.05, 0.05, 0);
            const noseMaterial = new THREE.MeshBasicMaterial({ color: '#66442c' });
            const nose = new THREE.Mesh(noseGeo, noseMaterial);
            nose.position.set(0, -0.1, faceComponentsZ); // 살색 앞면에 배치
            head.add(nose);
            character.nose = nose;

            // 입
            const mouthGeo = new THREE.BoxGeometry(0.2, 0.1, 0);
            const mouthMaterial = new THREE.MeshBasicMaterial({ color: '#66442c' });
            const mouth = new THREE.Mesh(mouthGeo, mouthMaterial);
            mouth.position.set(0, -0.25, faceComponentsZ); // 살색 앞면에 배치
            head.add(mouth);
            character.mouth = mouth;

            // Minecraft 스타일 몸통
            const bodyGeo = new THREE.BoxGeometry(0.8, 0, 0.4);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 }); // 살색 몸통
            const body = new THREE.Mesh(bodyGeo, bodyMaterial);
            body.castShadow = true;
            character.add(body);
            character.body = body;

            // 반팔 티셔츠 - 청바지 색
            const shirtGeo = new THREE.BoxGeometry(0.85, 0.7, 0.45);
            
            // 티셔츠 재질 배열
            const frontShirtMaterial = createShirtWithLogo('올리브영', 70, 70);
            
            // 뒷면에 로고 추가
            const textureLoader = new THREE.TextureLoader();
            const backShirtMaterial = new THREE.MeshStandardMaterial({
                color: 0x4169E1, // RoyalBlue
                roughness: 0.8,
                metalness: 0.1
            });
           

            const sideShirtMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1, roughness: 0.8, metalness: 0.1 }); // RoyalBlue
            
            const shirtMaterials = [
                sideShirtMaterial, // right
                sideShirtMaterial, // left
                sideShirtMaterial, // top
                sideShirtMaterial, // bottom
                backShirtMaterial,  // back
                frontShirtMaterial  // front
            ];
            
            const shirt = new THREE.Mesh(shirtGeo, shirtMaterials);
            shirt.castShadow = true;
            shirt.position.y = -0.15; // 몸통 아래쪽에 위치 (얼굴 아래)
            character.add(shirt);
            character.shirt = shirt;

            // 명찰 추가 (티셔츠 앞면에)
            const badgeData = createBadge();
            const badgeMaterial = badgeData.material;
            
            // 이미지 로드 후 비율에 맞게 명찰 크기 조정
            badgeData.textureLoader.load('cj_olive.png', 
                function(badgeTexture) {
                    console.log('명찰 이미지 로드 성공');
                    // 이미지의 원본 비율 계산
                    const aspectRatio = badgeTexture.image.width / badgeTexture.image.height;
                    
                    // 명찰 크기 설정 (높이 기준으로 너비 조정) - 1.1배로 확대
                    const badgeHeight = 0.15 * 1.1;
                    const badgeWidth = badgeHeight * aspectRatio;
                    
                    // 기존 명찰이 있다면 제거
                    if (character.badge) {
                        character.remove(character.badge);
                    }
                    
                    // 텍스처 설정
                    badgeTexture.wrapS = THREE.ClampToEdgeWrapping;
                    badgeTexture.wrapT = THREE.ClampToEdgeWrapping;
                    badgeMaterial.map = badgeTexture;
                    badgeMaterial.needsUpdate = true;
                    
                    // 올바른 비율로 명찰 생성
                    const badgeGeo = new THREE.PlaneGeometry(badgeWidth, badgeHeight);
                    const badge = new THREE.Mesh(badgeGeo, badgeMaterial);
                    badge.position.set(0.1, 0.0, 0.25); // X 위치를 0.2에서 0.1로 조정하여 왼쪽으로 이동
                    badge.rotation.x = 0; // 앞면을 향하도록
                    character.add(badge);
                    character.badge = badge;
                },
                function(progress) {
                    console.log('명찰 이미지 로딩 진행률:', (progress.loaded / progress.total * 100) + '%');
                },
                function(error) {
                    console.error('명찰 이미지 로드 실패:', error);
                }
            );

            // 반팔 팔 - 살색
            const armGeo = new THREE.BoxGeometry(0.3, 0.5, 0.3);
            const armMaterial = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 });
            
            const leftArm = new THREE.Mesh(armGeo, armMaterial);
            leftArm.castShadow = true;
            leftArm.position.set(0.55, -0.1, 0);
            character.add(leftArm);
            character.leftArm = leftArm;
            
            const rightArm = new THREE.Mesh(armGeo, armMaterial);
            rightArm.castShadow = true;
            rightArm.position.set(-0.55, -0.1, 0);
            character.add(rightArm);
            character.rightArm = rightArm;

            // 다리 - 바지 색상
            const legGeo = new THREE.BoxGeometry(0.35, 0.8, 0.35);
            const legMaterial = new THREE.MeshStandardMaterial({ color: pantsColor, roughness: 0.8, metalness: 0.1 });
            
            const leftLeg = new THREE.Mesh(legGeo, legMaterial);
            leftLeg.castShadow = true;
            leftLeg.position.set(0.2, -0.9, 0);
            character.add(leftLeg);
            character.leftLeg = leftLeg;
            
            const rightLeg = new THREE.Mesh(legGeo, legMaterial);
            rightLeg.castShadow = true;
            rightLeg.position.set(-0.2, -0.9, 0);
            character.add(rightLeg);
            character.rightLeg = rightLeg;
        }

        // NPC 캐릭터 생성 함수
        function createNPCCharacter() {
            const npc = new THREE.Group();
            scene.add(npc);
            
            // NPC는 화면 밖에서 시작 (랜덤한 위치)
            const spawnSide = Math.random() < 0.5 ? -1 : 1; // 왼쪽 또는 오른쪽
            npc.position.set(spawnSide * 30, 0.5, (Math.random() - 0.5) * 20);
            npc.rotation.y = -spawnSide * Math.PI / 2; // 카메라 방향으로 회전
            
            // 주인공과 비슷한 외형 (간소화된 버전)
            const characterMaterial = new THREE.MeshStandardMaterial({ roughness: 0.8, metalness: 0.1 });
            const skinColor = 0xFFDAB9;
            const pantsColor = 0x464646;
            const hairColor = 0x3b2219;
            
            // 머리
            const headGeo = new THREE.BoxGeometry(0.8, 0.8, 0.6);
            const headMaterials = [
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 }),
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 }),
                new THREE.MeshStandardMaterial({ color: hairColor, roughness: 0.8, metalness: 0.1 }),
                new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 }),
                new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 }),
                new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 })
            ];
            
            const head = new THREE.Mesh(headGeo, headMaterials);
            head.castShadow = true;
            head.position.y = 0.6;
            npc.add(head);
            
            // 몸통 (간단한 티셔츠)
            const bodyGeo = new THREE.BoxGeometry(0.75, 0.6, 0.35);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169E1, roughness: 0.8, metalness: 0.1 });
            const body = new THREE.Mesh(bodyGeo, bodyMaterial);
            body.castShadow = true;
            body.position.y = 0.1;
            npc.add(body);
            
            // 팔
            const armGeo = new THREE.BoxGeometry(0.3, 0.5, 0.3);
            const armMaterial = new THREE.MeshStandardMaterial({ color: skinColor, roughness: 0.8, metalness: 0.1 });
            
            const leftArm = new THREE.Mesh(armGeo, armMaterial);
            leftArm.castShadow = true;
            leftArm.position.set(0.6, 0.1, 0);
            npc.add(leftArm);
            
            const rightArm = new THREE.Mesh(armGeo, armMaterial);
            rightArm.castShadow = true;
            rightArm.position.set(-0.6, 0.1, 0);
            npc.add(rightArm);
            
            // 다리
            const legGeo = new THREE.BoxGeometry(0.35, 0.8, 0.35);
            const legMaterial = new THREE.MeshStandardMaterial({ color: pantsColor, roughness: 0.8, metalness: 0.1 });
            
            const leftLeg = new THREE.Mesh(legGeo, legMaterial);
            leftLeg.castShadow = true;
            leftLeg.position.set(0.2, -0.9, 0);
            npc.add(leftLeg);
            
            const rightLeg = new THREE.Mesh(legGeo, legMaterial);
            rightLeg.castShadow = true;
            rightLeg.position.set(-0.2, -0.9, 0);
            npc.add(rightLeg);
            
            // NPC 속성 설정
            npc.isNPC = true;
            npc.walkDirection = new THREE.Vector3(-spawnSide, 0, (Math.random() - 0.5) * 0.5).normalize();
            npc.walkSpeed = 0.01 + Math.random() * 0.01; // 0.01 ~ 0.02
            npc.lifeTime = 0;
            npc.maxLifeTime = 10000 + Math.random() * 10000; // 10-20초
            
            return npc;
        }
        
        // NPC 업데이트 함수
        function updateNPCs(delta) {
            // NPC 스폰 타이머 업데이트
            npcSpawnTimer += delta * 1000;
            
            // 첫 번째 NPC는 즉시 스폰 (3초 후)
            if (!isFirstNPCSpawned && npcSpawnTimer >= 3000) {
                const newNPC = createNPCCharacter();
                npcCharacters.push(newNPC);
                isFirstNPCSpawned = true;
                npcSpawnTimer = 0;
            }
            // 이후에는 5분마다 NPC 스폰 시도
            else if (isFirstNPCSpawned && npcSpawnTimer >= npcSpawnInterval && npcCharacters.length < maxNpcs) {
                const newNPC = createNPCCharacter();
                npcCharacters.push(newNPC);
                npcSpawnTimer = 0;
            }
            
            // 기존 NPC들 업데이트
            for (let i = npcCharacters.length - 1; i >= 0; i--) {
                const npc = npcCharacters[i];
                npc.lifeTime += delta * 1000;
                
                // NPC 이동
                npc.position.addScaledVector(npc.walkDirection, npc.walkSpeed);
                
                // NPC가 화면 밖으로 나가거나 생명주기가 끝나면 제거
                const distanceFromCenter = Math.sqrt(npc.position.x * npc.position.x + npc.position.z * npc.position.z);
                if (distanceFromCenter > 50 || npc.lifeTime >= npc.maxLifeTime) {
                    scene.remove(npc);
                    npcCharacters.splice(i, 1);
                }
            }
        }

        function playSound(type) {
            if (!audioCtx) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser");
                    return;
                }
            }
            
            let oscillator = audioCtx.createOscillator();
            let gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            gainNode.gain.setValueAtTime(0.2 * sfxVolume, audioCtx.currentTime);

            switch(type) {
                case 'ArrowUp': // 동일한 효과음
                case 'ArrowDown': // 동일한 효과음
                case 'ArrowLeft': // 동일한 효과음
                case 'ArrowRight': // 동일한 효과음
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(660, audioCtx.currentTime + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.15);
                    break;
                case 'beep': // 카운트다운 뚯뚯 소리
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                    oscillator.frequency.setValueAtTime(600, audioCtx.currentTime + 0.05);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.1);
                    break;
                case 'success': // 경쾌한 시작 소리
                    oscillator.type = 'sine';
                    // 상승하는 멜로디 (도-미-솔-도)
                    const successFreqs = [523, 659, 784, 1047]; // C5, E5, G5, C6
                    successFreqs.forEach((freq, i) => {
                        const osc = audioCtx.createOscillator();
                        const gain = audioCtx.createGain();
                        osc.connect(gain);
                        gain.connect(audioCtx.destination);
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.1);
                        gain.gain.setValueAtTime(0.15 * sfxVolume, audioCtx.currentTime + i * 0.1);
                        gain.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + i * 0.1 + 0.3);
                        osc.start(audioCtx.currentTime + i * 0.1);
                        osc.stop(audioCtx.currentTime + i * 0.1 + 0.3);
                    });
                    return;
                case 'incorrect': // Incorrect sound
                     oscillator.type = 'sawtooth';
                     oscillator.frequency.setValueAtTime(164, audioCtx.currentTime);
                     oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                     gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 0.3);
                     break;
                case 'gameover': // More Dramatic Game Over sound
                    oscillator.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0.3 * sfxVolume, audioCtx.currentTime);

                    // A rapid, descending minor scale
                    let freqsOver = [440, 415, 392, 349, 330, 294, 277, 261]; 
                    freqsOver.forEach((freq, i) => {
                         oscillator.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.07);
                    });
                    
                    // Final low, sustained note
                    oscillator.frequency.setValueAtTime(130, audioCtx.currentTime + freqsOver.length * 0.07);

                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + 1.2);
                    break;
            }

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 1.2);
        }

        function playAnimation(key) {
            playSound(key);
            // 모든 애니메이션 상태 초기화
            const resetAnimation = () => {
                character.leftArm.rotation.set(0, 0, 0);
                character.rightArm.rotation.set(0, 0, 0);
                character.leftLeg.rotation.set(0, 0, 0);
                character.rightLeg.rotation.set(0, 0, 0);
                character.head.rotation.set(0, 0, 0);
                character.rightArm.position.z = 0;
                character.position.y = 0.5;
                // character.rotation.y = Math.PI;
            };
            resetAnimation();

            const duration = 400; // ms

            switch(key) {
                case 'ArrowUp': // 트렌드리딩 - 멀리보기
                    character.head.rotation.x = -Math.PI / 16;
                    character.rightArm.rotation.x = -Math.PI / 2.5;
                    character.rightArm.position.z = -0.1; // 손을 앞으로 조금
                    setTimeout(resetAnimation, duration);
                    break;

                case 'ArrowDown': // 강한실행력 - 파워 스톰프
                    character.position.y = 0.3; // 살짝 웅크리기
                    character.leftLeg.rotation.x = -Math.PI / 4;
                    character.rightLeg.rotation.x = Math.PI / 4;
                    setTimeout(() => {
                        character.position.y = 0.7; // 점프!
                    }, 100);
                     setTimeout(() => {
                        character.position.y = 0.5; // 착지
                        character.leftLeg.rotation.x = 0;
                        character.rightLeg.rotation.x = 0;
                    }, 250);
                    setTimeout(resetAnimation, duration);
                    break;

                case 'ArrowLeft': // 협업,소통 - 신나는 댄스
                    character.rotation.y = Math.PI / 8;
                    character.leftArm.rotation.z = Math.PI / 4;
                    character.rightArm.rotation.z = -Math.PI / 4;
                    setTimeout(() => {
                        character.rotation.y = Math.PI / 8;
                        character.leftArm.rotation.z = -Math.PI / 4;
                        character.rightArm.rotation.z = Math.PI / 4;
                    }, duration / 2);
                    setTimeout(resetAnimation, duration);
                    break;

                case 'ArrowRight': // 함께성장 - 환호!
                    character.leftArm.rotation.x = -Math.PI * 0.9;
                    character.rightArm.rotation.x = -Math.PI * 0.9;
                    character.rightLeg.rotation.x = -Math.PI / 4; // 한쪽 다리 들기
                    setTimeout(resetAnimation, duration);
                    break;
            }
        }
        
        function createWaterSplash() {
            const particleCount = 100;
            const particleGeo = new THREE.SphereGeometry(0.05, 8, 8);
            const particleMat = new THREE.MeshBasicMaterial({ color: 0x00BFFF });

            for (let i = 0; i < particleCount; i++) {
                const particle = new THREE.Mesh(particleGeo, particleMat);
                particle.position.copy(character.position);
                particle.position.y += 0.8;
                
                particle.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 3,
                    (Math.random() * 2 + 2),
                    (Math.random() - 0.5) * 3
                );
                scene.add(particle);
                waterParticles.push(particle);
            }
        }
        
        // 대기화면 캐릭터 애니메이션
        let idleAnimationTimer = 0;
        let lastIdleAction = 0;
        const idleActions = ['dance', 'stretch', 'wave', 'nod', 'grassWalk'];
        
        // 걸어다니기 애니메이션
        let walkAnimationTimer = 0;
        let walkTargetPosition = { x: 0, z: 0 };
        let walkStartPosition = { x: 0, z: 0 };
        let walkProgress = 0;
        let isWalking = false;
        let walkDuration = 0;

        function startWalking() {
            if (!character || isWalking) return;
            
            // 랜덤한 목표 위치 설정 (원점에서 1-2.5 유닛 거리로 제한)
            const angle = Math.random() * Math.PI * 2;
            const distance = 1 + Math.random() * 1.5; // 1-2.5 유닛으로 제한
            walkTargetPosition.x = Math.cos(angle) * distance;
            walkTargetPosition.z = Math.sin(angle) * distance;
            
            // 카메라에서 너무 멀어지지 않도록 추가 제한
            const maxDistance = 2.5;
            const currentDistance = Math.sqrt(walkTargetPosition.x * walkTargetPosition.x + walkTargetPosition.z * walkTargetPosition.z);
            if (currentDistance > maxDistance) {
                const scale = maxDistance / currentDistance;
                walkTargetPosition.x *= scale;
                walkTargetPosition.z *= scale;
            }
            
            // 현재 위치를 시작 위치로 설정
            walkStartPosition.x = character.position.x;
            walkStartPosition.z = character.position.z;
            
            // 걸어다니기 설정
            isWalking = true;
            walkProgress = 0;
            walkDuration = 3000 + Math.random() * 2000; // 3-5초
            
            // 캐릭터가 목표를 바라보도록 회전
            const dx = walkTargetPosition.x - walkStartPosition.x;
            const dz = walkTargetPosition.z - walkStartPosition.z;
            const targetRotation = Math.atan2(dx, dz);
            character.rotation.y = targetRotation;
        }
        
        function updateWalking(delta) {
            if (!isWalking || !character) return;
            
            walkProgress += delta * 1000; // 밀리초로 변환
            const t = Math.min(walkProgress / walkDuration, 1);
            
            // 부드러운 보간 (ease-in-out)
            const smoothT = t * t * (3 - 2 * t);
            
            // 위치 업데이트
            let newX = walkStartPosition.x + (walkTargetPosition.x - walkStartPosition.x) * smoothT;
            let newZ = walkStartPosition.z + (walkTargetPosition.z - walkStartPosition.z) * smoothT;
            
            // 실시간 거리 체크 및 제한 (2.5 유닛 이내로 제한)
            const currentDistance = Math.sqrt(newX * newX + newZ * newZ);
            const maxDistance = 2.5;
            if (currentDistance > maxDistance) {
                const scale = maxDistance / currentDistance;
                newX *= scale;
                newZ *= scale;
            }
            
            character.position.x = newX;
            character.position.z = newZ;
            
            // 걸음걸이 애니메이션 (다리 움직임)
            const walkCycle = Math.sin(walkProgress * 0.01) * 0.3;
            character.leftLeg.rotation.x = walkCycle;
            character.rightLeg.rotation.x = -walkCycle;
            
            // 팔 흔들기
            character.leftArm.rotation.x = -walkCycle * 0.5;
            character.rightArm.rotation.x = walkCycle * 0.5;
            
            // 목표에 도달했으면
            if (t >= 1) {
                isWalking = false;
                character.leftLeg.rotation.x = 0;
                character.rightLeg.rotation.x = 0;
                character.leftArm.rotation.x = 0;
                character.rightArm.rotation.x = 0;
                
                // 잠시 대기 후 다시 걸어다니기 시작
                setTimeout(() => {
                    if (gameState === 'START') {
                        startWalking();
                    }
                }, 2000 + Math.random() * 3000);
            }
        }
        
        function teleportToCenter() {
            if (!character) return;
            
            // 순간이동 효과 (펑!)
            const originalScale = character.scale.clone();
            character.scale.set(0.1, 0.1, 0.1);
            character.position.set(0, 0.5, 0);
            character.rotation.y = Math.PI;
            
            // 부드럽게 원래 크기로 복원
            const scaleUp = () => {
                if (character) {
                    character.scale.lerp(originalScale, 0.1);
                    if (character.scale.distanceTo(originalScale) > 0.01) {
                        requestAnimationFrame(scaleUp);
                    } else {
                        character.scale.copy(originalScale);
                    }
                }
            };
            scaleUp();
        }

        function playIdleAnimation() {
            if (!character) return;
            
            const action = idleActions[Math.floor(Math.random() * idleActions.length)];
            const duration = 2000; // 2초
            
            switch(action) {
                case 'dance':
                    // 춤추기 - 좌우로 흔들리며 팔을 움직임
                    character.rotation.y = Math.PI / 8;
                    character.leftArm.rotation.z = Math.PI / 4;
                    character.rightArm.rotation.z = -Math.PI / 4;
                    setTimeout(() => {
                        if (character) {
                            character.rotation.y = 0;
                            character.leftArm.rotation.z = 0;
                            character.rightArm.rotation.z = 0;
                        }
                    }, duration);
                    break;
                    
                case 'grassWalk':
                    // 잔디밭을 걸어다니기 - 작은 걸음으로 잔디밭을 탐험
                    const grassWalkDuration = 4000; // 4초
                    const grassWalkSteps = 8;
                    let stepIndex = 0;
                    
                    const grassWalkInterval = setInterval(() => {
                        if (character && stepIndex < grassWalkSteps) {
                            // 작은 걸음걸이
                            const stepCycle = Math.sin(stepIndex * 0.5) * 0.2;
                            character.leftLeg.rotation.x = stepCycle;
                            character.rightLeg.rotation.x = -stepCycle;
                            
                            // 팔 흔들기
                            character.leftArm.rotation.x = -stepCycle * 0.3;
                            character.rightArm.rotation.x = stepCycle * 0.3;
                            
                            // 몸을 좌우로 살짝 기울이기
                            character.rotation.z = Math.sin(stepIndex * 0.3) * 0.1;
                            
                            // 머리를 좌우로 살짝 돌리기 (잔디를 보는 듯한 동작)
                            character.head.rotation.y = Math.sin(stepIndex * 0.4) * 0.2;
                            
                            stepIndex++;
                        } else {
                            clearInterval(grassWalkInterval);
                            if (character) {
                                character.leftLeg.rotation.x = 0;
                                character.rightLeg.rotation.x = 0;
                                character.leftArm.rotation.x = 0;
                                character.rightArm.rotation.x = 0;
                                character.rotation.z = 0;
                                character.head.rotation.y = 0;
                            }
                        }
                    }, 500);
                    break;
                    
                case 'stretch':
                    // 스트레치 - 양팔을 위로 올리고 몸을 뒤로 젖힘
                    character.leftArm.rotation.x = -Math.PI / 2;
                    character.rightArm.rotation.x = -Math.PI / 2;
                    character.head.rotation.x = -Math.PI / 12;
                    setTimeout(() => {
                        if (character) {
                            character.leftArm.rotation.x = 0;
                            character.rightArm.rotation.x = 0;
                            character.head.rotation.x = 0;
                        }
                    }, duration);
                    break;
                    
                case 'wave':
                    // 손 흔들기 - 한쪽 팔만 흔들기
                    character.rightArm.rotation.x = -Math.PI / 4;
                    character.rightArm.rotation.z = Math.PI / 6;
                    setTimeout(() => {
                        if (character) {
                            character.rightArm.rotation.x = 0;
                            character.rightArm.rotation.z = 0;
                        }
                    }, duration);
                    break;
                    
                case 'nod':
                    // 고개 끄덕이기 - 머리를 위아래로 움직임
                    const nodCount = 3;
                    let nodIndex = 0;
                    const nodInterval = setInterval(() => {
                        if (character && nodIndex < nodCount) {
                            character.head.rotation.x = nodIndex % 2 === 0 ? -Math.PI / 16 : Math.PI / 16;
                            nodIndex++;
                        } else {
                            clearInterval(nodInterval);
                            if (character) character.head.rotation.x = 0;
                        }
                    }, 300);
                    break;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = clock.getElapsedTime();
            
            if (waterParticles.length > 0) {
                waterParticles.forEach((p, index) => {
                    p.velocity.y -= 9.8 * delta;
                    p.position.addScaledVector(p.velocity, delta);
                    if (p.position.y < 0) {
                        scene.remove(p);
                        waterParticles.splice(index, 1);
                    }
                });
            }

            birds.forEach(bird => {
                bird.position.addScaledVector(bird.velocity, delta);
                // 날갯짓
                bird.children[0].rotation.z = Math.sin(elapsedTime * 20) * 0.5;
                bird.children[1].rotation.z = -Math.sin(elapsedTime * 20) * 0.5;
                if (bird.position.x > 60) {
                    bird.position.x = -60;
                    bird.position.y = Math.random() * 5 + 12;
                }
            });
            
            hotAirBalloons.forEach(balloon => {
                 balloon.position.y += Math.sin(elapsedTime * 0.5 + balloon.position.x) * 0.005;
            });

            // 대기화면에서만 애니메이션 실행 (카운트다운 중에는 중단)
            const startScreen = document.getElementById('start-screen');
            const countdownElement = document.getElementById('countdown');
            const isStartScreenVisible = startScreen && !startScreen.classList.contains('hidden');
            const isCountdownVisible = countdownElement && countdownElement.style.display !== 'none';
            
            // 오직 대기화면에서만 애니메이션 실행 (카운트다운 중에는 완전히 중단)
            if (isStartScreenVisible && !isCountdownVisible && character) {
                idleAnimationTimer += delta * 1000; // 밀리초로 변환
                
                // 걸어다니기 업데이트
                updateWalking(delta);
                
                // 말풍선 업데이트
                updateSpeechBubble(delta);
                
                // NPC 업데이트
                updateNPCs(delta);
                
                // 3-8초마다 랜덤 애니메이션 실행 (걸어다니지 않을 때만)
                if (!isWalking && idleAnimationTimer - lastIdleAction > 3000 + Math.random() * 5000) {
                    playIdleAnimation();
                    lastIdleAction = idleAnimationTimer;
                }
            } else {
                // 대기화면이 아니거나 카운트다운 중일 때는 모든 애니메이션 중단
                if (isWalking) {
                    isWalking = false;
                    if (character) {
                        character.leftLeg.rotation.x = 0;
                        character.rightLeg.rotation.x = 0;
                        character.leftArm.rotation.x = 0;
                        character.rightArm.rotation.x = 0;
                        character.rotation.z = 0;
                        character.head.rotation.y = 0;
                    }
                }
                // 게임 중에는 말풍선 숨기기
                if (isSpeechActive) {
                    speechBubble.classList.remove('show');
                    if (character.speechBubble3D) {
                        character.remove(character.speechBubble3D);
                        character.speechBubble3D = null;
                    }
                    isSpeechActive = false;
                    speechCooldown = 0;
                }
            }

            // Mouse-based camera movement
            const targetX = mouse.x * 0.8; 
            const targetY = 1.5 + mouse.y * 0.4;
            
            // Smoothly interpolate camera position
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (targetY - camera.position.y) * 0.05;
            
            if (shakeDuration > 0) {
                camera.position.x += (Math.random() - 0.5) * SHAKE_INTENSITY;
                camera.position.y += (Math.random() - 0.5) * SHAKE_INTENSITY;
                shakeDuration -= delta;
            }

            camera.lookAt(0, 1, 0);

            renderer.render(scene, camera);
        }

        function startGame() {
            // 1차 대기화면에서 2차 대기화면으로 이동
            startScreen.classList.add('hidden');
            howToPlayScreen.classList.remove('hidden');
        }

        function startGameFromHowToPlay() {
            // 2차 대기화면에서 게임 시작
            howToPlayScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            keyIndicators.classList.remove('hidden'); // 화살표 UI 표시
            
            // 3초 카운트다운 시작
            startCountdown();
        }

        function startCountdown() {
            // 카운트다운 시작 시 캐릭터를 제자리로 돌아오게 하기
            if (character) {
                isWalking = false;
                character.position.set(0, 0.5, 0);
                character.rotation.y = 0;
                character.leftLeg.rotation.x = 0;
                character.rightLeg.rotation.x = 0;
                character.leftArm.rotation.x = 0;
                character.rightArm.rotation.x = 0;
                character.rotation.z = 0;
                character.head.rotation.y = 0;
            }
            
            // 카운트다운 상태에서 소리 UI 보이기
            showVolumeControls();
            
            let count = 3;
            const countdownElement = document.createElement('div');
            countdownElement.id = 'countdown';
            countdownElement.style.cssText = `
                position: fixed;
                top: 200px;
                left: 50%;
                transform: translateX(-50%);
                font-size: 120px;
                font-weight: bold;
                color: #FFD700;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                z-index: 1000;
                pointer-events: none;
                width: 300px;
                height: 120px;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
                line-height: 1;
                white-space: nowrap;
            `;
            countdownElement.textContent = count;
            document.body.appendChild(countdownElement);

            const countdownInterval = setInterval(() => {
                count--;
                if (count > 0) {
                    countdownElement.textContent = count;
                    playSound('beep'); // 카운트다운 사운드
                } else {
                    countdownElement.textContent = '시작!';
                    playSound('success');
                    setTimeout(() => {
                        document.body.removeChild(countdownElement);
                        startGameAfterCountdown();
                    }, 500);
                    clearInterval(countdownInterval);
                }
            }, 1000);
        }

        function startGameAfterCountdown() {
            gameState = 'SHOWING';
            stage = INITIAL_STAGE;
            lives = INITIAL_LIVES;
            sequenceSpeed = INITIAL_SEQUENCE_SPEED;
            timeLimit = INITIAL_TIME_LIMIT;
            
            // 모든 게임 관련 UI 요소들 표시
            timerContainer.classList.remove('opacity-0');
            progressContainer.classList.remove('opacity-0');
            messageBox.style.opacity = '1';
            stageDisplay.style.opacity = '1'; // 기억력 점수 표시 보이기
            livesContainer.style.opacity = '1'; // 생명 표시 보이기
            
            // 게임 진행 중 상태에서 소리 UI 보이기
            showVolumeControls();
            
            if (character) scene.remove(character);
            createCharacter();
            
            updateUI();
            
            bgm.volume = bgmVolumeSlider.value / 100;
            bgm.currentTime = 0;
            const playPromise = bgm.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.log("Music auto-play was prevented. A user interaction is needed.");
                });
            }

            nextStage();
        }

        function calculateMemoryIndex(stage) {
            // 지수적 증가하되 적당한 기울기 (50 + 30 * (1.25^stage - 1))
            if (stage <= 0) return 50;
            
            const baseIndex = 50;
            const multiplier = 30; // 25에서 30으로 증가
            const growthRate = 1.25; // 1.2에서 1.25로 증가 (적당한 증가)
            
            const memoryScore = baseIndex + multiplier * (Math.pow(growthRate, stage) - 1);
            return Math.round(memoryScore);
        }

        function nextStage() {
            gameState = 'SHOWING';
            playerInput = [];
            const memoryScore = calculateMemoryIndex(stage);
            
            // 기억력 숫자에 zoom 효과 추가
            stageDisplay.classList.remove('iq-zoom');
            void stageDisplay.offsetWidth; // 강제 리플로우
            stageDisplay.textContent = `당신의 올영력은 아마도... ${memoryScore} 정도?`;
            stageDisplay.classList.add('iq-zoom');
            
            const keys = Object.keys(keywords);
            sequence = [];
            for (let i = 0; i < stage + 3; i++) {
                sequence.push(keys[Math.floor(Math.random() * keys.length)]);
            }
            showSequence();
        }

        function setupProgressIndicator() {
            progressContainer.innerHTML = '';
            for(let i=0; i<sequence.length; i++) {
                const dot = document.createElement('div');
                dot.className = 'progress-dot';
                progressContainer.appendChild(dot);
            }
        }
        
        async function showSequence() {
            // 게임 상태 확인
            if (gameState !== 'SHOWING') {
                console.log('showSequence: 게임 상태가 SHOWING이 아님:', gameState);
                return;
            }
            
            setupProgressIndicator();
            const dots = progressContainer.children;
            for (let i = 0; i < sequence.length; i++) {
                // 각 단계마다 게임 상태 확인
                if (gameState !== 'SHOWING') {
                    console.log('showSequence: 중간에 게임 상태 변경됨:', gameState);
                    return;
                }
                
                const key = sequence[i];
                await new Promise(resolve => setTimeout(resolve, sequenceSpeed));
                showMessage(keywords[key], key);
                playAnimation(key);
                if(dots[i]) {
                    dots[i].innerHTML = arrowIcons[key];
                    dots[i].style.backgroundColor = 'rgba(34, 197, 94, 0.9)'; // 초록색 배경
                    dots[i].style.color = 'white'; // 흰색 텍스트
                    dots[i].style.fontWeight = 'bold'; // 굵은 글씨
                    dots[i].style.fontSize = '24px'; // 큰 글씨
                }
            }
            await new Promise(resolve => setTimeout(resolve, sequenceSpeed));
            messageBox.className = messageBox.className.replace(/animate-\w+/g, '');
            messageBox.style.opacity = 0;

            // 최종 상태 확인 후 플레이어 턴 시작
            if (gameState === 'SHOWING') {
                startPlayerTurn();
            }
        }

        function startPlayerTurn() {
            // 게임 상태 확인
            if (gameState !== 'SHOWING') {
                console.log('startPlayerTurn: 게임 상태가 SHOWING이 아님:', gameState);
                return;
            }
            
            gameState = 'WAITING';
            playerInput = [];
            setupProgressIndicator(); // Reset indicators for player input
            startTimer();
        }

        function startTimer() {
            timerContainer.classList.remove('opacity-0');
            let timeLeft = timeLimit;
            timerBar.style.width = '100%';
            
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                // 타이머 실행 중에도 게임 상태 확인
                if (gameState !== 'WAITING') {
                    clearInterval(timerInterval);
                    return;
                }
                
                timeLeft -= 100;
                const widthPercentage = (timeLeft / timeLimit) * 100;
                timerBar.style.width = `${widthPercentage}%`;

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    handleIncorrectInput();
                }
            }, 100);
        }

        function handlePlayerInput(e) {
            if (gameState !== 'WAITING' || !keywords[e.key]) return;

            // 이미 시퀀스가 완료되었거나 잘못된 입력이 있었으면 추가 입력 무시
            if (playerInput.length >= sequence.length) return;

            playerInput.push(e.key);
            const currentKey = playerInput[playerInput.length - 1];
            const correctKey = sequence[playerInput.length - 1];
            
            const dots = progressContainer.children;

            if (currentKey !== correctKey) {
                if(dots[playerInput.length-1]) {
                    dots[playerInput.length-1].style.backgroundColor = 'rgba(239, 68, 68, 0.9)'; // 더 예쁜 빨간색
                    dots[playerInput.length-1].style.color = 'white'; // 흰색 텍스트
                    dots[playerInput.length-1].style.fontWeight = 'bold'; // 굵은 글씨
                    dots[playerInput.length-1].style.fontSize = '24px'; // 큰 글씨
                }
                handleIncorrectInput();
            } else {
                playAnimation(currentKey); // 플레이어 입력 시 캐릭터 움직임
                if(dots[playerInput.length-1]) {
                    dots[playerInput.length-1].innerHTML = arrowIcons[currentKey];
                    dots[playerInput.length-1].style.backgroundColor = 'rgba(34, 197, 94, 0.9)'; // 초록색 배경
                    dots[playerInput.length-1].style.color = 'white'; // 흰색 텍스트
                    dots[playerInput.length-1].style.fontWeight = 'bold'; // 굵은 글씨
                    dots[playerInput.length-1].style.fontSize = '24px'; // 큰 글씨
                }

                if (playerInput.length === sequence.length) {
                    handleCorrectSequence();
                }
            }
        }
        
        function handleIncorrectInput() {
            playSound('incorrect');
            clearInterval(timerInterval);
            timerContainer.classList.add('opacity-0');
            createWaterSplash();
            lives--;
            updateUI();
            if (lives <= 0) {
                gameOver();
            } else {
                // 게임 상태를 명확하게 설정
                gameState = 'SHOWING';
                playerInput = []; // 플레이어 입력 초기화
                setTimeout(() => {
                    messageBox.className = messageBox.className.replace(/animate-\w+/g, '');
                    messageBox.style.opacity = 0;
                    showSequence();
                }, 1500);
            }
        }

        function handleCorrectSequence() {
            clearInterval(timerInterval);
            timerContainer.classList.add('opacity-0');

            // 빵파레 효과 추가
            createConfetti();
            showMessage('성공!', null, '#FFD700'); // Gold
            stage++;
            // 난이도 상승
            sequenceSpeed = Math.max(200, sequenceSpeed - 20);
            timeLimit = Math.max(3000, timeLimit - 100);

            setTimeout(() => {
                 messageBox.className = messageBox.className.replace(/animate-\w+/g, '');
                 messageBox.style.opacity = 0;
                 nextStage();
            }, 1000);
        }

        function gameOver() {
            console.log('gameOver 함수 호출됨');
            bgm.pause();
            playSound('gameover');
            gameState = 'GAMEOVER';
            
            console.log('게임오버 화면 표시 시도');
            gameOverScreen.classList.remove('hidden');
            console.log('게임오버 화면 클래스:', gameOverScreen.className);
            
            // Dramatic Effect
            flashOverlay.style.opacity = '0.7';
            setTimeout(() => { flashOverlay.style.opacity = '0'; }, 100);
            shakeDuration = 0.5;
            
            // 5초 후 자동으로 최초화면으로 돌아가기
            clearTimeout(gameOverTimeout); // 이전 타임아웃 제거
            gameOverTimeout = setTimeout(() => {
                resetGame();
            }, 5000);
        }

        function showVolumeControls() {
            const volumeControls = document.getElementById('volume-controls');
            if (volumeControls) {
                volumeControls.style.display = 'flex';
            }
        }

        function hideVolumeControls() {
            const volumeControls = document.getElementById('volume-controls');
            if (volumeControls) {
                volumeControls.style.display = 'none';
            }
        }

        let uiVisible = true; // UI 표시 상태 추적

        function toggleGameUI() {
            uiVisible = !uiVisible;
            
            if (uiVisible) {
                // UI 보이기
                timerContainer.classList.remove('opacity-0');
                progressContainer.classList.remove('opacity-0');
                messageBox.style.opacity = '1';
                stageDisplay.style.opacity = '1';
                livesContainer.style.opacity = '1';
                showVolumeControls();
            } else {
                // UI 숨기기
                timerContainer.classList.add('opacity-0');
                progressContainer.classList.add('opacity-0');
                messageBox.style.opacity = '0';
                stageDisplay.style.opacity = '0';
                livesContainer.style.opacity = '0';
                hideVolumeControls();
            }
        }


        function createConfetti() {
            const confettiCount = 50;
            const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.style.cssText = `
                    position: fixed;
                    width: 10px;
                    height: 10px;
                    background-color: ${colors[Math.floor(Math.random() * colors.length)]};
                    top: 50%;
                    left: 50%;
                    pointer-events: none;
                    z-index: 1000;
                    border-radius: 2px;
                `;
                
                document.body.appendChild(confetti);
                
                const angle = Math.random() * Math.PI * 2;
                const velocity = 0.2 + Math.random() * 0.5; // 속도 더욱 감소 (0.5-1.5 → 0.2-0.7)
                const gravity = 0.02; // 중력 더욱 감소 (0.05 → 0.02)
                const rotation = Math.random() * 360;
                const rotationSpeed = (Math.random() - 0.5) * 1.5; // 회전 속도 더욱 감소 (3 → 1.5)
                
                let x = 0;
                let y = 0;
                let vx = Math.cos(angle) * velocity;
                let vy = Math.sin(angle) * velocity - 0.5; // 초기 수직 속도 더욱 감소 (-1 → -0.5)
                let currentRotation = rotation;
                
                const animateConfetti = () => {
                    x += vx;
                    y += vy;
                    vy += gravity;
                    currentRotation += rotationSpeed;
                    
                    confetti.style.left = `${50 + x}%`;
                    confetti.style.top = `${50 + y}%`;
                    confetti.style.transform = `rotate(${currentRotation}deg)`;
                    confetti.style.opacity = Math.max(0, 1 - Math.abs(y) / 200);
                    
                    if (y < 200 && confetti.parentNode) {
                        requestAnimationFrame(animateConfetti);
                    } else {
                        if (confetti.parentNode) {
                            confetti.parentNode.removeChild(confetti);
                        }
                    }
                };
                
                requestAnimationFrame(animateConfetti);
            }
        }

        function showMessage(text, key = null, color = '#FBBF24') {
            messageBox.textContent = text;
            messageBox.style.color = color;
            messageBox.style.opacity = 1;

            // Remove previous animation classes
            if (text === '성공!') {
                messageBox.className = "text-6xl md:text-8xl font-bold text-yellow-300"; // 성공 시 더 큰 글자
            } else {
                messageBox.className = "text-4xl md:text-6xl font-bold text-yellow-300"; // 기본 크기
            }
            void messageBox.offsetWidth;

            const vector = new THREE.Vector3(0, 1.6, 0); // 캐릭터 머리 위 기준점
            vector.project(camera);

            const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
            const y = (vector.y * -0.5 + 0.5) * renderer.domElement.clientHeight;

            messageBox.style.left = `${x}px`;
            messageBox.style.top = `${y}px`;

            switch(key) {
                case 'ArrowUp':
                    messageBox.classList.add('animate-up');
                    break;
                case 'ArrowDown':
                    messageBox.classList.add('animate-down');
                    break;
                case 'ArrowLeft':
                    messageBox.classList.add('animate-left');
                    break;
                case 'ArrowRight':
                    messageBox.classList.add('animate-right');
                    break;
                default:
                    // For "Success" message, just fade in
                    messageBox.style.transform = 'translate(-50%, -50%)';
                    break;
            }
        }

        function updateUI() {
            const lifeElements = livesContainer.children;
            for(let i = 0; i < lifeElements.length; i++) {
                if (i < lives) {
                    lifeElements[i].classList.remove('lost');
                } else {
                    lifeElements[i].classList.add('lost');
                }
            }
            const memoryScore = calculateMemoryIndex(stage);
            
            // 기억력 숫자에 zoom 효과 추가
            stageDisplay.classList.remove('iq-zoom');
            void stageDisplay.offsetWidth; // 강제 리플로우
            stageDisplay.textContent = `당신의 올영력은 아마도... ${memoryScore} 정도?`;
            stageDisplay.classList.add('iq-zoom');
        }
        function resetGame() {
            clearTimeout(gameOverTimeout); // 자동 리셋 타임아웃 취소
            startScreen.classList.remove('hidden');
            howToPlayScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            keyIndicators.classList.add('hidden'); // 화살표 UI 숨기기
            gameState = 'START';
            lives = 3;
            stage = 1;
            
            // NPC들 정리
            npcCharacters.forEach(npc => {
                scene.remove(npc);
            });
            npcCharacters = [];
            npcSpawnTimer = 0;
            isFirstNPCSpawned = false; // 첫 번째 NPC 스폰 플래그 리셋
            
            // 모든 게임 관련 UI 요소들 숨기기
            timerContainer.classList.add('opacity-0');
            progressContainer.classList.add('opacity-0');
            messageBox.style.opacity = '0';
            stageDisplay.style.opacity = '0'; // 기억력 점수 표시 숨기기
            livesContainer.style.opacity = '0'; // 생명 표시 숨기기
            
            // 음악, 소리 UI 숨기기 (게임오버 후 다시도전 상태)
            hideVolumeControls();
            
            // 걸어다니기 중단
            isWalking = false;
            walkAnimationTimer = 0;
            lastIdleAction = 0;
            
            // 캐릭터를 원래 자리로 리셋
            if (character) {
                character.position.set(0, 0.5, 0);
                character.rotation.y = 0;
                character.scale.set(1, 1, 1);
            }
            
            updateUI();
            
            // 게임 리셋 후 걸어다니기 시작 (최초 초기화와 동일)
            setTimeout(() => {
                if (gameState === 'START') {
                    startWalking();
                }
            }, 1000);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        startButton.addEventListener('click', startGame);
        howToPlayButton.addEventListener('click', startGameFromHowToPlay);
        retryButton.addEventListener('click', resetGame);

        // 터치 이벤트 추가 (모바일 지원)
        startButton.addEventListener('touchend', function(e) {
            e.preventDefault();
            startGame();
        });
        
        howToPlayButton.addEventListener('touchend', function(e) {
            e.preventDefault();
            startGameFromHowToPlay();
        });
        
        retryButton.addEventListener('touchend', function(e) {
            e.preventDefault();
            resetGame();
        });
        
        bgmVolumeSlider.addEventListener('input', (e) => {
            bgm.volume = e.target.value / 100;
        });

        sfxVolumeSlider.addEventListener('input', (e) => {
            sfxVolume = e.target.value / 100;
        });

        window.addEventListener('keydown', handlePlayerInput);
        window.addEventListener('resize', () => {
            const canvasContainer = document.getElementById('game-container');
            const width = canvasContainer.clientWidth;
            const height = canvasContainer.clientHeight;
            
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
            
            // 모바일에서 카메라 위치 조정
            if (width < 768) {
                camera.position.set(0, 2, 3);
            } else {
                camera.position.set(0, 2, 5);
            }
            camera.lookAt(0, 1, 0);
        });
        window.addEventListener('mousemove', onMouseMove);
        
        // 화살표 버튼 클릭 이벤트 추가
        document.querySelectorAll('.key-indicator[data-key]').forEach(button => {
            button.addEventListener('click', (e) => {
                const key = e.currentTarget.getAttribute('data-key');
                // 키보드 이벤트와 동일한 이벤트 객체 생성
                const keyEvent = new KeyboardEvent('keydown', {
                    key: key,
                    code: key,
                    keyCode: key === 'ArrowUp' ? 38 : key === 'ArrowDown' ? 40 : key === 'ArrowLeft' ? 37 : 39,
                    which: key === 'ArrowUp' ? 38 : key === 'ArrowDown' ? 40 : key === 'ArrowLeft' ? 37 : 39,
                    bubbles: true,
                    cancelable: true
                });
                handlePlayerInput(keyEvent);
            });
            
            // 터치 이벤트 추가 (모바일 지원)
            button.addEventListener('touchend', (e) => {
                e.preventDefault();
                const key = e.currentTarget.getAttribute('data-key');
                // 키보드 이벤트와 동일한 이벤트 객체 생성
                const keyEvent = new KeyboardEvent('keydown', {
                    key: key,
                    code: key,
                    keyCode: key === 'ArrowUp' ? 38 : key === 'ArrowDown' ? 40 : key === 'ArrowLeft' ? 37 : 39,
                    which: key === 'ArrowUp' ? 38 : key === 'ArrowDown' ? 40 : key === 'ArrowLeft' ? 37 : 39,
                    bubbles: true,
                    cancelable: true
                });
                handlePlayerInput(keyEvent);
            });
        });

        // 폰트가 모두 로드된 후 3D 씬을 초기화합니다.
        document.fonts.ready.then(function () {
            init3D();
            document.getElementById('start-button').classList.add('pulsing');
        });
        
        // 게임 대기상태에서 하트와 볼륨 UI 숨기기
        livesContainer.style.opacity = '0';
        hideVolumeControls();
        
        // 초기 슬라이더 값 설정
        bgmVolumeSlider.value = BGM_DEFAULT_VOLUME;
        sfxVolumeSlider.value = SFX_DEFAULT_VOLUME;

    </script>
</body>
</html>

